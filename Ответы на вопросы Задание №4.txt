Что такое Тест дизайн? Для чего нужны Техники тест дизайна?
Тест дизайн – это этап процесса тестирования ПО, на котором проектируются и создаются тестовые случаи (тест кейсы), в соответствии с определёнными ранее критериями качества и целями тестирования.

Цель тест-дизайна - создать максимально эффективный набор кейсов, покрывающий наиболее важные аспекты тестируемого ПО, т.е. минимизировать количество тестов, необходимых для нахождения большинства серьезных ошибок.
Для разработки набора тестов, обеспечивающего более- менее высокий уровень покрытия можно использовать специальные инструменты либо техники тест дизайна.

План работы над тест дизайном:
1. Анализ имеющихся проектных артефактов: документация (спецификации, требования, планы), модели, исполняемый код и т.д.
2. Написание спецификации по тест дизайну (Test Design Specification)
3. Проектирование и создание тестовых случаев (Test Cases)

Роли, ответственные за тест дизайн: 
- Тест аналитик - определяет "ЧТО тестировать?"
- Тест дизайнер - определяет "КАК тестировать?"

Попросту говоря, задача тест аналитиков и дизайнеров сводится к тому, чтобы используя различные стратегии и техники тест дизайна, создать набор тестовых случаев, обеспечивающий оптимальное тестовое покрытие тестируемого приложения. 
Однако, на большинстве проектов эти роли не выделяется, а доверяется обычным тестировщикам, что не всегда положительно сказывается на качестве тестов, тестировании и, как из этого следует, на качестве программного обеспечения (конечного продукта).

Существуют следующие подходы к оценке и измерению тестового покрытия:

- Покрытие требований (Requirements Coverage) - оценка покрытия тестами функциональных и нефункциональных требований к продукту путем построения матриц трассировки (traceability matrix).
- Покрытие кода (Code Coverage) - оценка покрытия исполняемого кода тестами, путем отслеживания непроверенных в процессе тестирования частей программного обеспечения.
- Тестовое покрытие на базе анализа потока управления - оценка покрытия основанная на определении путей выполнения кода программного модуля и создания выполняемых тест кейсов для покрытия этих путей.

Различия:
Метод покрытия требований сосредоточен на проверке соответствия набора проводимых тестов требованиям к продукту, в то время как анализ покрытия кода - на полноте проверки тестами, разработанной части продукта (исходного кода), а анализ потока управления - на прохождении путей в графе или модели выполнения тестируемых функций (Control Flow Graph).

Ограничения:
- Метод оценки покрытия кода не выявит нереализованные требования, так как работает не с конечным продуктом, а с существующим исходным кодом.
- Метод покрытия требований может оставить непроверенными некоторые участки кода, потому что не учитывает конечную реализацию.

Техники тест-дизайна (Software testing techniques):

1. Статические (Static):
Reviews:
- Неформальное ревью (Informal review)
- Прохождение (Walkthrough)
- Техническое ревью (Technical Review)
- Инспекция (Inspection)

2. Статический анализ (Static Analysis):
- Поток данных (Data Flow)
- Поток управления (Control Flow)
- Путь (Path)
- Стандарты (Standards)

3. Динамические (Dynamic):
- Белый ящик (White-box, Structure-Based)
- Выражение (Statement)
- Решение (Decision)
- Ветвь (Branch)
- Условие (Condition)
- Конечный автомат (FSM)

4. Основанные на опыте (Experience-based):
- Предугадывание ошибки (Error Guessing - EG);
- Исследовательское тестирование (Exploratory testing);
- Ad-hoc testing;
- Attack Testing;

5. Черный ящик (Black-box, Specification-based):
- Эквивалентное Разделение (Equivalence Partitioning - EP)
- Анализ Граничных Значений (Boundary Value Analysis - BVA)
- Комбинаторные техники (Combinatorial Test Techniques)
- Переходы между состояниями (State transition)
- Случаи использования (Use case testing)
- Domain testing
- Decision Table Testing
- Classification Tree Method
- Cause-Effect Graphing
- Scenario Testing
- Random Testing
- Syntax Testing
- Check List Based Testing
- Risk-Based Testing
- User Journey Test

Что такое Классы эквивалентности?
Класс эквивалентности (Equivalence class) – это набор входных (или выходных) данных ПО, которые обрабатываются программой по одному алгоритму и тестирование одного значения приводит к тому же результату, что и тестирование другого.
То есть, это некое множество значений, которое вы можете подставлять в программу и получать один и тот же результат. Результатом можем быть не только конкретные значения, действия программы, но и просто область применения. 
Поэтому, самые простые классы эквивалентности, на которые делятся проверки, это 2 основных класса: позитивные и негативные сценарии.

Пример:
Система скоринга рассчитывает процентную ставку по кредиту для клиента исходя из его возраста, который вводится в форму:

От 18 до 25 лет – 18%
От 25 до 45 лет – 16 %
Свыше 45 лет – 20%

1. Мы определяем 2 основных класса – это позитивные и негативные сценарии.
2. Позитивными сценариями будут все значения, которые приводят к получению результата, негативными сценариями – значения, результаты которых не описаны, как ожидаемый результат.
3. Далее мы делим класс позитивных сценариев 3 класса вводимых значений 18-24, 25-44 и 45 +
4. В классе негативных сценариев мы формируем значения, исходя из необходимости проверки отказов программы, поэтому мы имеем 0, 1-17, отрицательные значения, ввод символов и т.д.

Результатом данного разбиения будет значение или диапазон значений, в котором нам необходимо выполнить всего одну проверку с любым значением из диапазона данных. Могут возникнуть такие ситуации, как одно значение в диапазоне. 
Это тоже отдельный класс эквивалентности и тоже требует проверки.

Итого мы имеем.

Позитивные проверки: Ввод значений: 19, 30, 48 (значения могут быть любыми из данного диапазона класса)
Негативные проверки: 0, 3, -1, А и т.д.
Что такое Граничные значения?

Граничные значения – техника тест-дизайна, которая дополняет классы эквивалентности дополнительными проверками на границе изменения условий.
Годы исследований в области тестирования показали, что большая часть дефектов находится именно на стыке значений, которые меняют условия работы программы.
Поэтому, помимо граничного значения мы используем для тестирования дополнительно 2 значения, значение перед границей и значение после границы.


Пример:

Система скоринга рассчитывает процентную ставку по кредиту для клиента исходя из его возраста, который вводится в форму:

От 18 до 25 лет – 18%
От 25 до 45 лет – 16 %
Свыше 45 лет – 20%

1. Границы наших классов: 17, 18, 19, 24, 25, 26, 44, 45, 46 и max.
Значение max обычно уточняется у Заказчика или аналитика. Если не могут предоставить, то следует бросить его и не проверять необходимо подобрать значение, соответствующее здравому смыслу.

2. Также, у нас есть негативный класс, это от 0 до 18. Поэтому тут мы тоже должны использовать для тестирования граничные значения: -1, 0, 1, 17,18

3. Далее исключаем повторяющиеся значения, и получаем значения для проверки элемента ввода данных:
        -1, 0, 1, 17, 18, 19, 24, 25, 26, 44, 45, 46, max.

4. Накладываем граничные значения на значения классов эквивалентности, исключаем лишние проверки, пользуясь правилом «достаточно одного значения для проверки одного класса» и финализируем список.

5. Если ранее у нас были 3 значения для 3-х классов, 19, 30 и 48, то после определения граничных значений, мы можем исключить из списка значения 30 и 48 и заменить их пред граничными значениями, такими как 26 (вместо 30) и 46 (вместо 48).

Граничные значения определяются не только для числовых значений, но и для буквенных (например, границы алфавита и кодировки), даты и времени, смысловых значений.

Что такое Таблица принятия решений?
Таблица принятия решений — способ компактного представления модели со сложной логикой; инструмент для упорядочения сложных бизнес требований, которые должны быть реализованы в продукте. Это взаимосвязь между множеством условий и действий.
Эта техника основывается на принципе, что каждый тест-кейс должен проверять конкретный функциональный аспект приложения.
Таблица принятия решений представляет собой таблицу с двумя осями — вертикальной и горизонтальной. 
В вертикальной оси перечислены функциональные аспекты приложения, которые должны быть проверены, в то время как в горизонтальной оси перечислены различные варианты использования приложения.

Таблица принятия решений, как правило, разделяется на 4 квадранта:

1) Условия  | 2) Варианты выполнения действий
-------------------------------------------
3) Действия | 4) Необходимость действий

1)Условия — список возможных условий.

2) Варианты выполнения действий — комбинация из выполнения и/или невыполнения условий этого списка.

3) Действия — список возможных действий.

4) Необходимость действий — указание надо или не надо выполнять соответствующее действие для каждой из комбинаций условий.

Плюсы использования таблицы принятия решений:
+ Позволяет систематизировать проблему и найти наиболее эффективное решение
+ Упрощает принятие решений на основе объективных критериев
+ Позволяет сравнивать различные альтернативы
+ Помогает избежать влияния эмоций и предубеждений на принятие решений
+ Позволяет быстро и эффективно принимать решения
+ Позволяет объективно оценить риски каждой альтернативы

Минусы использования таблицы принятия решений:
- Может быть трудно определить критерии оценки
- Важность критериев может быть недостаточно точно определена
- Некоторые альтернативы могут быть недостаточно изучены
- Не учитывает некоторые факторы, которые могут оказывать влияние на принятие решений
- Может быть сложно учесть все возможные альтернативы и критерии


Что такое Попарное тестирование?
Относится к техникам тест-дизайна 2-го уровня отвечает за вариативность и комбинаторику данных при проверке ПО.
Основной техникой тест-дизайна pairwise testing (попарное тестирование)- это метод тестирования, при котором каждая возможная комбинация значений параметров приложения тестируется вместе с каждой другой возможной комбинацией, при этом каждый параметр приложения используется хотя бы один раз. 
Pairwise основан на принципе, который гласит, что 98% всех ошибок возникают в результате влияния одного или двух параметров.

Суть техники заключается в минимизации вариативности комбинаций проверок, достаточных для обеспечения высокого качества ПО. 

Простыми словами, в данной технике применяется правило Парето, 80 % качества можно достичь всего 20% проверок комбинаций данных.

Рассмотрим пример простого приложения, которое имеет четыре параметра: "Кнопка", "Текст", "Цвет" и "Размер". 
Каждый параметр может принимать одно из трех значений. В этом случае, при использовании традиционного метода тестирования, для покрытия всех возможных комбинаций потребуется 3^4 (3 в 4 степени) = 81 тестовый сценарий. 
Однако, при использовании метода попарного тестирования, можно сократить количество тестовых сценариев до 9, при этом каждая возможная комбинация значений параметров будет протестирована хотя бы один раз.

Перечислите Методы комбинаторного тестирования
Методы комбинаторного тестирования основаны на комбинаторике, которая позволяет эффективно генерировать тестовые данные, покрывающие максимальное количество возможных сценариев. 
Таким образом, комбинаторное тестирование ПО помогает улучшить покрытие кода и уменьшить количество ошибок.

* Метод парных комбинаций (Pairwise testing)
Данный метод позволяет сократить количество возможных комбинаций значений параметров тестируемого продукта. Он основан на том, что в большинстве случаев наличие дефекта зависит только от двух параметров. 
Поэтому для тестирования достаточно проверить все возможные комбинации пар параметров.

* Метод полного перебора (All Combinations)
Метод полный перебор (англ. exhaustive testing) ( или в научной среде многомерного комбинаторного тестирования (MCC)) — это метод комбинаторного тестирования, при котором все возможные комбинации параметров тестируются. 
Этот метод является наиболее надежным, но при этом может быть крайне трудоемким и затратным в плане времени и ресурсов. 
Он используется для продуктов с большим количеством параметров, у которых взаимодействие между ними существенно влияет на работу продукта.

* Метод обязательных комбинаций (EC - Each choice testing)
Метод обязательных комбинаций ( по научному называется Метод ортогонального тестирования (Orthogonal array testing)). Данный метод предлагает использовать специально разработанные таблицы для выбора оптимальных комбинаций значений параметров. Такие таблицы называются ортогональными массивами. Они позволяют покрыть все возможные комбинации значений параметров, при этом минимизируя количество тест-кейсов.

Техника в комбинаторике, когда каждое значение должно использоваться хотя бы раз, называется методом обязательных комбинаций или методом тестирования с обязательными параметрами (Mandatory Parameter Testing, MPT). 
Этот метод гарантирует, что все обязательные параметры будут протестированы в каждой комбинации.

* Метод размытого комбинаторного тестирования (Fuzzy Combinatorial Testing)
Метод размытого комбинаторного тестирования (Fuzzy Combinatorial Testing) — это метод, который позволяет рассматривать значения параметров тестовых данных как нечеткие множества, а не точные значения. 
Это позволяет получить более гибкое тестирование, при котором система проверяется на устойчивость к некоторым небольшим отклонениям значений параметров.

Для реализации метода размытого комбинаторного тестирования используются нечеткие алгоритмы, которые определяют, какие значения параметров следует использовать в тестах, чтобы они были максимально эффективными. 
Эти алгоритмы также могут определять, какие комбинации параметров нужно использовать, чтобы увеличить покрытие тестов.

Пример применения метода размытого комбинаторного тестирования: тестирование системы, которая занимается фильтрацией спама в электронной почте. 
В этом случае, одним из параметров является «частота вхождения слова в письмо». Вместо того чтобы использовать точные значения частоты вхождения слова, в методе размытого комбинаторного тестирования используются нечеткие значения, например, «низкая», «средняя» и «высокая». 
Таким образом, можно проверить, как система реагирует на разные уровни частоты вхождения слова в письмо.

* Метод базового выбора (BC - Base choice testing): - метод начинается с определения одного базового тестового примера. 
Базовый тестовый пример может быть определен по любому критерию, включая простейший, наименьший или первый. Также это мб  «наиболее вероятное значение» с точки зрения конечного пользователя. 
Из базового тестового примера создаются новые тестовые примеры, изменяя интересующие значения одного параметра за раз, сохраняя значения других параметров фиксированными в базовом тестовом примере.





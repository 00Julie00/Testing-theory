Что такое функциональное тестирование (Functional/Behavioral testing)?
Какие виды тестирования относятся к функциональному тестированию?

Функциональное тестирование (functional testing)-  Тестирование, основанное на анализе спецификации функциональности компонента или системы (ISTQB)

Функциональное тестирование выполняется чтобы убедиться, что каждая функция программного приложения ведет себя так, как указано в документе с требованиями. В большинстве случаев это выполняется методом black box testing.

Для функционального тестирования принято использовать две техники:
- Тестирование на основе требований: содержит все функциональные спецификации, которые составляют основу для всех тестов, которые будут проводиться;
- Тестирование на основе бизнес-сценариев: содержит информацию о том, как система будет восприниматься с точки зрения бизнес-процесса;

Основные виды функционального тестирования:
- Unit Testing: модульное тестирование обычно выполняется разработчиком и влечет за собой написание тестов, которые будут вызывать методы в каждом модуле и проверять их, передавая требуемые параметры и проверяя соответствие возвращаемого значения ожидаемому. Покрытие кода - важная часть модульного тестирования, где должны существовать test cases, охватывающие: 
- Line coverage;
- Code path coverage; 
- Method coverage;
- Smoke Testing: тестирование, которое проводится после выпуска каждой сборки. Это также называется build verification testing;
- Sanity Testing: тестирование, которое проводится для того, чтобы убедиться, что все основные и жизненно важные функции приложения / системы работают правильно. Обычно это делается после Smoke Testing;
- Regression Tests: тестирование проводится для того, чтобы убедиться, что добавление нового кода, улучшений, исправление ошибок не нарушает существующую функциональность или не вызывает нестабильности и ПО все еще работает в соответствии со спецификациями. Регрессионные тесты не должны быть такими обширными, как фактические функциональные тесты, но должны гарантировать объем покрытия, подтверждающий стабильность функциональности;
- Integration Tests: когда система полагается на несколько функциональных модулей, которые работают по отдельности, но должны работать согласованно когда объединены вместе, чтобы достичь сквозного сценария, проверка таких сценариев называется интеграционным тестированием;
- Beta/Usability Testing: продукт демонстрируется реальному пользователю в среде, приближенной к проду, и они тестируют продукт. Это похоже на User Acceptance testing;
- System testing: тестирование, которое выполняется для всей системы, чтобы проверить, работает ли она должным образом после интеграции всех модулей или компонентов;
- End to end testing: проводится для проверки функциональности продукта. Это тестирование выполняется только после завершения тестирования системной интеграции, включая функциональные и нефункциональные требования;

Критерии начала функционального тестирования:
- Requirement Specification document определен и утвержден;
- Подготовлены тест-кейсы;
- Созданы тестовые данные;
- Среда для тестирования готова, все необходимые инструменты доступны и готовы;
- Всё или часть приложения разработано, модульно протестировано и готово к тестированию;

Критерии окончания функционального тестирования:
- Выполнение всех функциональных тестов завершено;
- Нет критических или открытых ошибок P1, P2;
- Сообщенные ошибки были подтверждены;

Этапы функционального тестирования:
1. Первый шаг заключается в определении функциональности продукта, который необходимо протестировать, и он включает в себя тестирование основных функций, условий ошибок и сообщений, тестирование удобства использования, то есть, является ли продукт удобным для пользователя или нет, и т. д.
2. Следующим шагом является создание входных данных для проверяемой функциональности в соответствии со спецификацией требований.
3. Позже, из спецификации требований, определяется результат для тестируемой функциональности.
4. Подготовленные тест-кейсы исполняются.
5. Фактический результат, то есть результат после выполнения тест-кейса, и ожидаемый результат (определенный из спецификации требований) сравниваются, чтобы определить, работает ли функциональность должным образом или нет.

Что такое нефункциональное тестирование (Non-Functional testing)?
Какие виды тестирования относятся к не функциональному тестированию?

Нефункциональное тестирование проводится для проверки нефункциональных требований приложения, таких как производительность, безопасность, совместимость, надежность, удобство использования и т. д. 
В большинстве случаев это выполняется методом black box testing. Оно проверяет, соответствует ли поведение системы требованиям по всем аспектам, не охваченные функциональным тестированием. 
В нашем повседневном тестировании много внимания уделяется функциональному тестированию и функциональным требованиям и клиенты также заинтересованы в выполнении функциональных требований, которые напрямую связаны с функциональностью приложения, но когда ПО выходит на рынок и используется реальными конечными пользователями, у них есть шансы столкнуться с проблемами. Эти проблемы не связаны с функциональностью системы, но могут негативно повлиять на пользовательский опыт.

Нефункциональные требования могут быть отражены как:
- Пользовательские / Технические истории (User /Technical Stories): запись нефункциональных требований в виде пользовательской истории такая же, как и запись любых других требований. 
Единственная разница между пользователем и технической историей заключается в том, что пользовательская история требует обсуждения и имеет видимость (? visibility);

- В критериях приемки (Acceptance criteria): это точка, которая определяется для принятия продукта заказчиком. 
Нефункциональное требование должно быть включено в критерии приемки, но иногда невозможно проверить нефункциональные требования с каждой историей, то есть с каждой итерацией. 
Следовательно, требования следует добавлять или тестировать только с соответствующей итерацией;

- В артефактах (Artifact): для нефункциональных требований следует подготовить отдельный артефакт, это, в свою очередь, поможет лучше понять, что нужно тестировать и как это можно делать в итерациях;

Виды нефункционального тестирования :
* Тестирование производительности (Performance Testing)
* Нагрузочное тестирование (Load Testing)
* Стрессовое тестирование (Stress Testing)
* Объемное тестирование (Volume Testing)
* Тестирование восстановления (Recovery Testing)
* Тестирование отказоустойчивости (Failover Testing)
* Тестирование эффективности (Efficiency Testing)
* Тестирование аварийного восстановления (Disaster Recovery Testing)
* Тестирование установки (Installation Testing)
* Тестирование документации (Documentation Testing)
* Тестирование на удобство использования (Usability Testing)
* Тестирование графического интерфейса пользователя (User Interface Testing)
* Тестирование совместимости (Compatibility Testing)
* Тестирование обслуживаемости (Maintainability Testing)
* Тестирование безопасности (Security Testing)
* Тестирование масштабируемости (Scalability Testing)
* Тестирование выносливости (Endurance Testing)
* Тестирование надежности (Reliability Testing)
* Тестирование соответствия (Compliance Testing)
* Тестирование локализации (Localization Testing)
* Тестирование интернационализации (Internationalization Testing)
* Тестирование переносимости (Portability Testing)
* Тестирование на основе базового уровня (Baseline Testing)

Примеры чек-листов:

1. Тестирование производительности:
- Время отклика (The response time) приложения, то есть сколько времени требуется для загрузки приложения, за какое время любой ввод, предоставленный приложению, обеспечивает вывод, время обновления браузера и т. д.;
- Пропускную способность (Throughput) следует проверять по количеству транзакций, завершенных во время нагрузочного теста;
- Настройка среды (Environment) должна быть такой же, как и в реальной среде, иначе результаты не будут такими же;
- Время процесса (Process time) - такие действия, как импорт и экспорт Excel, любые вычисления в приложении должны быть протестированы;
- Совместимость (Interoperability) должна быть проверена, т.е. программное обеспечение должно иметь возможность взаимодействовать с другим программным обеспечением или системами;
- Необходимо проверить время ETL, то есть время, затраченное на извлечение, преобразование и загрузку данных из одной базы данных в другую;
- Необходимо проверить возрастающую нагрузку (Load) на приложение;

2. Тестирование безопасности:
- Аутентификация (Authentication): только достоверный пользователь может войти в систему;
- Авторизация (Authorized): пользователь должен иметь возможность входить в те модули, для которых он авторизован или к которым пользователю был предоставлен доступ;
- Пароль: Требование пароля должно быть подтверждено, т.е. пароль должен соответствовать тому, как это требование определяется, то есть длине, специальным символам, числам и т. д.;
- Тайм-аут: если приложение неактивно, оно должно истечь по таймауту в указанное время;
- Резервное копирование данных: резервное копирование данных должно быть выполнено в указанное время и данные должны быть скопированы в безопасное место;
- Внутренние ссылки на веб-приложение не должны быть доступны, если размещены непосредственно в браузере;
- Вся коммуникация должна быть зашифрована;

3. Тестирование документации:
- Пользовательская и системная документация;
- Документы для учебных целей;

Что такое Статическое/Динамическое тестирование?

Тестирование, как статическое так и динамическое, должно быть направлено на получение обоих типов подтверждения (верификация и валидация), хотя и должно допускать, что подтверждение не будет получено немедленно из-за обнаружения дефектов. (ГОСТ 56920)

Статическое тестирование (Static Testing, Non-execution technique или verification) подразумевает проверку вручную или с помощью инструментов программного кода без его запуска, а также проверку документации.

Почему требуется статическое тестирование:
- Обнаружение ошибок / недостатков на ранних этапах: при создании ПО нельзя полагаться исключительно на динамическое тестирование, поскольку оно выявляет ошибки или недостатки программного продукта на более позднем этапе, что может стоить разработчикам много времени и усилий для отладки;
- Увеличение размера ПО: по мере увеличения размера программного продукта становится трудно справиться с ним, поскольку эффективность покрытия кода снижается;

Динамическое тестирование занимает много времени: несмотря на то, что динамическое тестирование выявляет ошибку и предоставляет некоторые подробности относительно ошибки, исправление ошибки по-прежнему требует времени и усилий, поскольку оно включает в себя обнаружение сбоя от тестового примера до основной причины, что в целом усложняет процесс;
Динамическое тестирование дорогое: как упоминалось ранее, для динамического тестирования требуются тестовые примеры, и выполнение этого само по себе является дорогостоящим, потому что тестовые примеры должны быть сначала созданы, затем выполнены и проверены, а также должны поддерживаться, что требует большой работы со стороны тестировщиков;
Динамическое тестирование (Dynamic Testing, Execution technique или validation) подразумевает запуск кода для проведения функциональных и нефункциональных проверок ПО. Основная цель этого тестирования - подтвердить, что программный продукт работает в соответствии с требованиями бизнеса. Преимуществами динамического тестирования являются выявление сложных дефектов, которые не могут быть обнаружены статическим тестированием, обнаружение угроз безопасности, проблем с производительностью и т.п.

Что такое Черный/Серый/Белый ящик тестирования(White/Black/Grey Box testing)?
Самым высоким уровнем в иерархии подходов к тестированию будет понятие метода. 
Некоторые виды тестирования могут выполняться методом как черного ящика, так и белого. Если упростить, то отличаются они знанием внутреннего устройства объекта тестирования.

Тестирование методом черного ящика (black box testing): Тестирование, функциональное или нефункциональное, без знания внутренней структуры компонента или системы (ISTQB).
Другие названия: Behavioral Testing, Specification-Based Testing, Input-Output Testing, непрозрачный ящик (opaque-box), закрытый ящик (closed-box), тестирование на основе спецификации (specification-based testing) или тестирование с глазу на глаз (eye-to-eye testing).
Тестирование методом «черного ящика» - это стратегия, в которой тестирование основано исключительно на требованиях и спецификациях, при этом мы не знаем, как устроена внутри тестируемая система и работаем исключительно с внешними интерфейсами тестируемой системы или компонента. Тестирование черного ящика может быть применено на всех уровнях - модульном, интеграционном, системном и приемочном.

Преимущества Black box testing:
+ Тестировщику не обязательно иметь технический опыт. Важно проводить тестирование, оказываясь на месте пользователя и думая с его точки зрения;
+ Тестирование можно начинать после завершения разработки проекта / приложения. И тестировщики, и разработчики работают независимо, не мешая друг другу;
+ Это более эффективно для больших и сложных приложений;
+ Дефекты и несоответствия можно выявить на ранней стадии тестирования;

Недостатки Black box testing:
- Без каких-либо технических или программных знаний есть вероятность пропустить возможные условия тестируемого сценария;
- В оговоренное время есть вероятность протестировать не все входные и выходные значения;
- Полный Test Coverage невозможен для больших и сложных проектов;

Тестирование методом белого ящика (white-box testing): Тестирование, основанное на анализе внутренней структуры компонента или системы (ISTQB).

White box testing нужно:
1. Чтобы убедиться, что:
- Все независимые пути в модуле были проверены хотя бы один раз;
- Все логические решения проверены на их истинное и ложное значения;
- Все циклы выполняются на своих границах и в пределах своих рабочих границ валидности внутренних структур данных;

2. Чтобы обнаружить следующие типы ошибок:
- Логическая ошибка имеет тенденцию закрасться в нашу работу, когда мы разрабатываем и реализуем функции, условия или элементы управления, которые не входят в программу;
- Ошибки проектирования из-за разницы между логическим потоком программы и фактической реализацией;
- Типографические ошибки и проверка синтаксиса;

Техника белого ящика применима на разных уровнях тестирования - модульном, интеграционном и системном, но чаще применяется для юнит-тестирования этого участка кода самим разработчиком или SDET. 
Тестирование белого ящика - это больше, чем тестирование кода: это тестирование путей.​ Обычно тестируемые пути находятся внутри модуля (модульное тестирование). 
Но мы можем применить эту же методику для тестирования путей между модулями внутри подсистем, между подсистемами внутри систем, и даже между целыми системами.

Тестирование белого ящика - это покрытие требований в коде:
- Code coverage;
- Segment coverage: каждый оператор кода выполняется один раз;
- Branch Coverage or Node Testing: покрытие каждой ветки кода из всех возможных было выполнено;
- Compound Condition Coverage: Для нескольких условий проверяется каждое условие с несколькими путями и комбинацией разных путей для достижения этого условия;
- Basis Path Testing: каждый независимый путь в коде взят на тестирование;
- Data Flow Testing (DFT): в этом подходе вы отслеживаете конкретные переменные посредством каждого возможного вычисления, тем самым определяя набор промежуточных путей через код. DFT имеет тенденцию отражать зависимости, но в основном это происходит через последовательности манипуляций с данными. Короче говоря, каждая переменная данных отслеживается, и ее использование проверяется. Этот подход имеет тенденцию обнаруживать ошибки, такие как переменные, которые используются, но не инициализируются, или объявлены, но не используются, и т.д. (компиляторы/линтеры/IDE уже вполне способны на это сами);
- Path Testing: тестирование пути - это определение и покрытие всех возможных путей прохождения через код;
- Loop Testing: эти стратегии относятся к тестированию одиночных циклов, составных (concatenated) циклов и вложенных циклов;

Процесс White box testing:
- Анализируется реализация программы;
- В программе определяются возможные маршруты;
- Выбираются такие входные данные, чтобы программа выполнила выбранные пути. Это называется сенсибилизацией путей. Заранее определяются ожидаемые результаты для входных данных;
- Тесты выполняются;
- Результаты анализируются;

Преимущества White box testing:
+ тестирование может производиться на ранних этапах: нет необходимости ждать создания пользовательского интерфейса;
+ можно провести более тщательное тестирование, с покрытием большого количества путей выполнения программы;

Недостатки White box testing:
- Количество выполняемых путей может быть настолько большим, что не удастся проверить их все. Как правило, попытка протестировать все пути выполнения с помощью тестирования белого ящика так же невозможна, как и тестирование всех комбинаций всех входных данных при тестировании черного ящика;
- Выбранные тест-кейсы могут не содержать данные, которые будут чувствительны к ошибкам. 

Тестирование белого ящика предполагает, что поток управления правильный (или близок к правильному). 
Поскольку эти тесты основаны на существующих путях, с помощью нельзя обнаружить несуществующие пути;
Тестировщик должен обладать навыками программирования для того, чтобы понять и Оценить тестируемое программное обеспечение;

Что такое Компонентное(Component or Unit Testing) /Интеграционное (Integration Testing)
/Системное (System Testing)/Приемочное тестирования (Acceptance Testing)?

С этими терминами часто происходит путаница. Если ссылаться на глоссарий ISTQB, то все они - синонимы:
- Модуль, юнит (module, unit): См. компонент.
- Модульное, юнит тестирование (module testing, unit testing): См. компонентное тестирование.
- Компонент (component): Наименьший элемент программного обеспечения, который может быть протестирован отдельно.
- Компонентное тестирование (component testing): Тестирование отдельных компонентов программного обеспечения (IEEE 610).

Тем не менее, некоторые источники описывают ситуацию несколько иначе:

Модульное тестирование (оно же юнит-тестирование) используется для тестирования какого-либо одного логически выделенного и изолированного элемента системы (отдельные методы класса или простая функция, subprograms, subroutines, классы или процедуры) в коде. 
Очевидно, что это тестирование методом белого ящика и чаще всего оно проводится самими разработчиками. 

Целью тестирования модуля является не демонстрация правильного функционирования модуля, а демонстрация наличия ошибки в модуле, а также в определении степени готовности системы к переходу на следующий уровень разработки и тестирования. 
На уровне модульного тестирования проще всего обнаружить дефекты, связанные с алгоритмическими ошибками и ошибками кодирования алгоритмов, типа работы с условиями и счетчиками циклов, а также с использованием локальных переменных и ресурсов. 
Ошибки, связанные с неверной трактовкой данных, некорректной реализацией интерфейсов, совместимостью, производительностью и т.п. обычно пропускаются на уровне модульного тестирования и выявляются на более поздних стадиях тестирования. 
Изоляция тестируемого блока достигается с помощью заглушек (stubs), манекенов (dummies) и макетов (mockups).

Компонентное тестирование - тип тестирования ПО, при котором тестирование выполняется для каждого отдельного компонента отдельно, без интеграции с другими компонентами. 
Его также называют модульным тестированием (Module testing), если рассматривать его с точки зрения архитектуры. Как правило, любое программное обеспечение в целом состоит из нескольких компонентов. Тестирование на уровне компонентов (Component Level testing) имеет дело с тестированием этих компонентов индивидуально. Это один из самых частых типов тестирования черного ящика, который проводится командой QA. Для каждого из этих компонентов будет определен сценарий тестирования, который затем будет приведен к Test case высокого уровня -> детальным Test case низкого уровня с предварительными условиями.

Исходя из глубины уровней тестирования, компонентное тестирование можно классифицировать как:
- Тестирование компонентов в малом (CTIS - Component testing In Small): тестирование компонентов может проводиться с или без изоляции остальных компонентов в тестируемом программном обеспечении или приложении. Если это выполняется с изоляцией другого компонента, то это называется CTIS;
- Тестирование компонентов в целом (CTIL - Component testing In Large) - тестирование компонентов, выполненное без изоляции других компонентов в тестируемом программном обеспечении или приложении;

Интеграционное тестирование (integration testing): Тестирование, выполняемое для обнаружения дефектов в интерфейсах и во взаимодействии между интегрированными компонентами или системами. 

Интеграционное тестирование предназначено для проверки насколько хорошо два или более компонента ПО взаимодействуют друг с другом, а также взаимодействия с различными частями системы (операционной системой, оборудованием либо связи между различными системами). С технологической точки зрения интеграционное тестирование является количественным развитием компонентного, поскольку также оперирует интерфейсами модулей и подсистем и требует создания тестового окружения, включая заглушки (Stub) на месте отсутствующих модулей. Основная разница между компонентным и интеграционным тестированием состоит в целях, то есть в типах обнаруживаемых дефектов, которые, в свою очередь, определяют стратегию выбора входных данных и методов анализа. В частности, на уровне интеграционного тестирования часто применяются методы, связанные с покрытием интерфейсов, например, вызовов функций или методов, или анализ использования интерфейсных объектов, таких как глобальные ресурсы, средства коммуникаций, предоставляемых операционной системой.

Уровни интеграционного тестирования:
1. Компонентный интеграционный уровень (CIT - Component Integration testing): Проверяется взаимодействие между компонентами одной системы после проведения компонентного тестирования. 
Программные компоненты или модули могут быть определены в разное время совершенно разными группами спецификаций, component integration testing выполняется чтобы убедиться, что даже после различий в разработке модулей интеграция всего работает вместе. 
В этом случае также важно учесть отрицательные случаи, так как компоненты могут делать предположения относительно данных;

2. Системный интеграционный уровень (SIT - System Integration testing): - это полное тестирование всей системы, состоящей из множества подсистем. 
Основная цель SIT - обеспечить правильное функционирование всех зависимостей программных модулей и сохранение целостности данных между отдельными модулями всей системы. 
SUT (System Under Test) может состоять из аппаратного обеспечения, базы данных, программного обеспечения, комбинации аппаратного и программного обеспечения или системы, требующей взаимодействия с человеком (HITL - Human in the Loop Testing). 
SIT имеет предварительное условие, при котором несколько базовых интегрированных систем уже прошли системное тестирование. Затем SIT проверяет необходимые взаимодействия между этими системами в целом. 
Результаты SIT передаются в UAT (пользовательское приемочное тестирование);

Интеграция может быть как программной, так и софт-железо:
- HSIT - Hardware Software Integration Testing: представляет собой процесс тестирования компонентов компьютерного программного обеспечения (CSC - Computer Software Components) на предмет функциональности высокого уровня в целевой аппаратной среде. 
Тестирование черного ящика - это основной тип тестирования, используемый на этом уровне тестирования. Целью тестирования интеграции аппаратного / программного обеспечения является проверка поведения разработанного программного обеспечения, интегрированного в аппаратный компонент. Цель тестирования интеграции аппаратного и программного обеспечения на основе требований (Requirement based Hardware-Software Integration Testing) - убедиться, что программное обеспечение на целевом компьютере удовлетворяет высокоуровневым требованиям (high-level requirements);

- SSIT - Software Software Integration Testing: это Computer Software Component Testing, работающего в среде целевого компьютера при моделировании всей системы (других CSC), и на функциональности высокого уровня. 
Оно фокусируется на поведении CSC в смоделированной среде хоста / цели. Для проверки интеграции программного обеспечения используются разные подходы;

Подходы к интеграционному тестированию:
1. Подход Большого взрыва (Big Bang Approach): “Вид подхода к интеграционному тестированию, при котором элементы программного или аппаратного обеспечения, или и то и другое, собираются в компонент или в целую систему сразу, а не по этапам.” ( IEEE 610). Все или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если Test case и их результаты записаны неверно, то сам процесс интеграции сильно осложнится, что станет преградой для команды тестирования при достижении основной цели интеграционного тестирования;

2. Инкрементальный подход (Incremental Approach): при таком подходе тестирование выполняется путем объединения двух или более логически связанных модулей. 
Затем другие связанные модули поэтапно добавляются и тестируются для правильного функционирования. 
Процесс продолжается до тех пор, пока все модули не будут соединены и успешно протестированы. 
Осуществляется разными методами:

- Нисходящий подход (Top-Down Approach): Вначале тестируются все высокоуровневые модули, и постепенно один за другим добавляются низкоуровневые. 
Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере готовности они заменяются реальными активными компонентами. 
Преимущества: Локализация неисправностей проще. Возможность получить ранний прототип. Основные недостатки дизайна могут быть найдены и исправлены в первую очередь. 
Недостатки: Нужно много заглушек. Модули на более низком уровне тестируются недостаточно;

- Восходящий подход (Bottom-Up Approach): В восходящей стратегии каждый модуль на более низких уровнях последовательно тестируется с более высокоуровневыми модулями, пока не будут протестированы все модули. 
Требуется помощь драйверов для тестирования. Данный подход считается полезным, если все или практически все модули, разрабатываемого уровня, готовы. Также данный подход помогает определить по результатам тестирования уровень готовности приложения. 
Пример низкоуровневого модуля - модуль, который заведует хранением токенов авторизации. Высокоуровневый - модуль авторизации, в состав которого помимо прочего входит модуль токенов. 
Преимущества: Локализация ошибок проще. Не тратится время на ожидание разработки всех модулей, в отличие от подхода Большого взрыва. 
Недостатки: Критические модули (на верхнем уровне архитектуры ПО), которые контролируют поток приложения, тестируются последними и могут быть подвержены дефектам. Ранний прототип невозможен;

- Гибридный/сэндвич-подход (Sandwich/Hybrid/Bi-Directional Approach): Представляет собой комбинацию восходящего и нисходящего подходов. 
Здесь целью является средний слой, в то время как драйверы заменяют верхний слой, а заглушки нижний пока компоненты этих слоев не будут разработаны;

Критерии начала и окончания Integration Testing:
Критерии начала:
- завершено модульное тестирование;
На входе:
- Software Requirements Data;
- Software Design Document;
- Software Verification Plan;
- Software Integration Documents;
Действия:
- На основе требований высокого и низкого уровня (High and Low-level requirements) создайте test cases and procedures;
- Комбинируйте сборки низкоуровневых модулей, которые реализуют общую функциональность;
- Разработайте тестовую обвязку (test harness);
- Протестируйте сборку;
- После прохождения теста сборка объединяется с другими сборками и тестируется до тех пор, пока система не будет интегрирована как единое целое;
- Повторите все тесты на целевой processor-based platform и получите результаты;
Критерии выхода:
- Успешное завершение интеграции Программного модуля на целевое Hardware;
- Правильная работа программного обеспечения в соответствии с указанными требованиями;
На выходе:
- Integration test reports;
- SVCP - Software Test Cases and Procedures;

Системное тестирование означает тестирование всей системы в целом, оно выполняется после интеграционного тестирования, чтобы проверить, работает ли вся система целиком должным образом. 
В основном это тестирование типа «черный ящик», которое оценивает работу системы с точки зрения пользователя с помощью документа спецификации и оно не требует каких-либо внутренних знаний о системе, таких как дизайн или структура кода.

Основное внимание уделяется следующему:
- Внешние интерфейсы;
- Многопрограммность и сложный функционал;
- Безопасность;
- Восстановление;
- Производительность;
- Гладкое (smooth) взаимодействие оператора и пользователя с системой;
- Возможность установки;
- Документация;
- Удобство использование;
- Нагрузка / стресс;

Зачем нужно системное тестирование?
- Очень важно завершить полный цикл тестирования, и ST - это этап, на котором это делается;
- ST выполняется в среде, аналогичной production environment, и, следовательно, заинтересованные стороны могут получить хорошее представление о реакции пользователя;
- Это помогает свести к минимуму устранение неполадок после развертывания и количество обращений в службу поддержки;
- На этом этапе STLC тестируются архитектура приложения и бизнес-требования. Это тестирование очень важно, и оно играет важную роль в предоставлении клиенту качественного продукта;

Критерии начала системного тестирования:
- Система должна соответствовать критериям окончания интеграционного тестирования, то есть все test cases должны быть выполнены, и не должно быть открытых критических ошибок или ошибок с приоритетом P1, P2;
- System Test Plan должен быть одобрен и подписан;
- Test cases/scenarios/scripts должны быть готовы к выполнению;
- Все нефункциональные требования должны быть доступны, и для них должны быть созданы test cases;
- Среда тестирования должна быть готова;

Критерии окончания системного тестирования:
- Все test cases должны быть выполнены;
- В открытом состоянии не должно быть критических, приоритетных или связанных с безопасностью ошибок;
- Если какие-либо ошибки со средним или низким приоритетом находятся в открытом состоянии, они должны быть исправлены с согласия клиента;
- Отчет о выходе (Exit Report) должен быть отправлен;

Приемочное тестирование (acceptance testing): Формальное тестирование по отношению к потребностям, требованиям и бизнес процессам пользователя, проводимое с целью определения соответствия системы критериям приемки и дать возможность пользователям, заказчикам или иным авторизованным лицам определить, принимать систему или нет. (IEEE 610)

После того, как процесс тестирования системы завершен командой тестирования, весь продукт передается клиенту и/или нескольким его пользователям для проверки приемлемости (acceptability). 
Е2Е бизнес-потоки проверяются аналогично в сценариях в реальном времени. Подобная производственной среда будет тестовой средой для приемочного тестирования (Staging, Pre-Prod, Fail-Over, UAT environment). Это метод тестирования черного ящика, при котором проверяется только функциональность, чтобы убедиться, что продукт соответствует указанным критериям приемки.

Виды приемочного тестирования:
- Пользовательское приемочное тестирование (UAT - User Acceptance Testing, validation, end-user testing) выполняется пользователем или клиентом чтобы определить, может ли ПО быть принято (accepted) или нет и проверить ПО на соответствие бизнес-требованиям. Могут существовать такие бизнес-требования и процессы, которые известны только конечным пользователям, и они либо пропускаются, либо неправильно интерпретируются, поэтому приемочное тестирование выполняется конечными пользователями, знакомыми с бизнес-требованиями;

- Бизнес - приемочное тестирование (BAT - Business Acceptance Testing) необходимо для оценки того, соответствует ли Продукт бизнес-целям и задачам. 
BAT в основном фокусируется на бизнес-преимуществах (финансах), которые являются довольно сложными из-за меняющихся рыночных условий / прогрессирующих технологий, так что текущая реализация может претерпеть изменения, которые приведут к дополнительным затратам. Даже Продукт, отвечающий техническим требованиям, может не пройти BAT по этим причинам;

- Контрактное приемочное тестирование (CAT - Contract Acceptance Testing) - это контракт, который определяет, что после того, как Продукт будет запущен в течение заранее определенного периода, должен быть проведен приемочный тест, и он должен пройти все приемочные тест-кейсы. Подписанный здесь контракт называется Соглашением об уровне обслуживания (SLA), которое включает условия, по которым платеж будет производиться только в том случае, если услуги Продукта соответствуют всем требованиям, что означает, что контракт выполнен. Иногда этот контракт может заключаться до того, как Продукт будет запущен. В любом случае, контракт должен быть четко определен с точки зрения периода тестирования, областей тестирования, условий по проблемам, возникающим на более поздних этапах, платежей и т. д.;

- Правовое приемочное тестирование (RAT - Regulations/Compliance Acceptance Testing) необходимо для оценки того, нарушает ли Продукт правила и нормы, установленные правительством страны, в которой он выпускается. 
Это может быть непреднамеренным, но отрицательно скажется на бизнесе. Обычно разрабатываемый Продукт / приложение, предназначенный для выпуска во всем мире, должен пройти RAT, поскольку в разных странах / регионах действуют разные правила и положения, определенные его руководящими органами. Если какие-либо правила и нормы нарушаются для какой-либо страны, то этой стране или конкретному региону в этой стране не будет разрешено использовать Продукт и это будет считаться отказом (Failure). Вендоры Продукта несут прямую ответственность, если Продукт будет выпущен даже при наличии нарушения;

- Эксплуатационное приемочное тестирование (OAT - Operational Acceptance testing) - это тип тестирования программного обеспечения, который оценивает эксплуатационную готовность программного приложения до его выпуска в производство. 
Целью эксплуатационного тестирования является обеспечение бесперебойной работы системы в ее стандартной эксплуатационной среде (SOE - standard operating environment). 
В основном это тестирование восстановления, совместимости, ремонтопригодности, доступности технической поддержки, надежности, восстановления после сбоя, локализации и т. д (recovery, compatibility, maintainability, technical support availability, reliability, fail-over, localization);

- Альфа-тестирование (Alpha Testing) проводят для оценки продукта в среде разработки / тестирования специализированной командой тестировщиков, обычно называемой альфа-тестерами. 
Здесь отзывы и предложения тестировщиков помогают улучшить использование Продукта, а также исправить определенные ошибки;

- Бета-тестирование, полевые испытания (Beta Testing, Field Testing) проводят для оценки Продукта, предоставляя его реальным конечным пользователям, обычно называемым бета-тестерами / бета-пользователями, в их среде. 
Собирается постоянная обратная связь от пользователей, и проблемы устраняются. Кроме того, это помогает в улучшении Продукта, чтобы обеспечить удобство работы пользователей. 
Тестирование происходит неконтролируемым образом, что означает, что у пользователя нет ограничений на использование Продукта;

Что такое Позитивное/Негативное тестирование?

Позитивное тестирование (Positive Testing) – это вид тестирования, при котором проверяются тестовые сценарии, соответствующие действиям, которые выполнял бы конечный пользователь при взаимодействии с продуктом. Позитивное тестирование подразумевает выполнение тестового сценария только с правильными и достоверными данными.
Иногда в программном продукте может быть несколько способов выполнения определенной функции или задачи. Это делается либо для того, чтобы дать конечному пользователю больше выбора действий, либо для того, чтобы сделать продукт более последовательным и удобным в использовании. Процесс проверки всех этих способов называется тестированием “альтернативного пути”, и это один из видов позитивного тестирования.
При тестировании альтернативного пути мы тестируем продукт, чтобы убедиться, что он соответствует требованиям и работает правильно. Но вместо того, чтобы использовать наиболее очевидный путь, мы выбираем несколько менее очевидные сценарии.
Важно отметить, что при этом мы все равно используем те же самые данные и ожидаем получить тот же самый результат. Таким образом, мы проверяем, что продукт работает хорошо не только в основном сценарии использования, но и во всех альтернативных сценариях.
Негативное тестирование (Negative Testing), также называемое “Error path testing”, “Failure testing”, обычно проводится для обеспечения стабильности приложения.

Негативное тестирование – это процесс применения как можно более творческого подхода для проверки работы приложения в случае получения недостоверных данных. Его цель – проверить, отображаются ли ошибки пользователю там, где они должны отображаться, и корректно ли обрабатываются недопустимые значения.
Надежность приложения может быть оценена только с помощью эффективно разработанных негативных сценариев. Негативное тестирование выявляет потенциальные дефекты в приложении, которые могут серьезно повлиять на использование продукта в целом. Также такое тестирование может быть полезным для определения условий, при которых приложение может дать сбой.

Рассмотрим пример. Допустим, вам нужно написать негативные тест-кейсы для проверки шариковой ручки. Основное предназначение ручки – возможность писать на бумаге.
Тест-кейсы негативного тестирования могут быть следующими:
- Смените материал, на котором должна писать ручка, с бумаги на ткань или кирпич, и посмотрите, будет ли она по-прежнему писать.
- Опустите ручку в жидкость и проверьте, пишет ли она.
- Замените стержень ручки на пустой и проверьте, перестанет ли она писать.

Что такое Альфа (Alpha Testing)/Бета тестирование(Beta Testing)?

Виды приемочного тестирования.
Альфа-тестирование (Alpha Testing) проводят для оценки продукта в среде разработки / тестирования специализированной командой тестировщиков, обычно называемой альфа-тестерами. 
Здесь отзывы и предложения тестировщиков помогают улучшить использование Продукта, а также исправить определенные ошибки;

Бета-тестирование, полевые испытания (Beta Testing, Field Testing) проводят для оценки Продукта, предоставляя его реальным конечным пользователям, обычно называемым бета-тестерами / бета-пользователями, в их среде. 
Собирается постоянная обратная связь от пользователей, и проблемы устраняются. Кроме того, это помогает в улучшении Продукта, чтобы обеспечить удобство работы пользователей. 
Тестирование происходит неконтролируемым образом, что означает, что у пользователя нет ограничений на использование Продукта;


Что такое Интуитивное/Исследовательское тестирование?

Исследовательское тестирование (exploratory testing): Неформальный метод проектирования тестов, при котором тестировщик активно контролирует проектирование тестов в то время, как эти тесты выполняются, и использует полученную во время тестирования информацию для проектирования новых и улучшенных тестов. (Bach)

Тестировщик участвует когнитивно. Он активно, целенаправленно, с любопытством исследует тестируемое программное обеспечение, всегда принимая на себя ответственность каждую минуту решать, какой путь к тому, что он выбрал для исследования, является наиболее многообещающим. Нет никаких искусственных ограничений на разведку. Тестировщик может свободно использовать любые доступные источники информации, включая спецификации, записи службы технической поддержки, реализации сопоставимого программного обеспечения конкурентами и (конечно) эксперименты (тесты), которые эмпирически раскрывают информацию. Нет никаких ограничений на методы тестирования, которые могут использовать исследователи - например, любая степень автоматизации подойдет. Однако исследователь не просто перезапускает старые тесты, а тестирует чтобы учиться. Вероятно, он будет внимательно изучать поведение программы во время ее тестирования, ища новые идеи о том, как она может выйти из строя, как ее можно было бы в дальнейшем протестировать или измерить, и насколько полезны эти тесты на данном этапе разработки. 

Подход к тестированию:
- Используйте эвристики для управления тестированием;
- Выполнение и создание тест-кейсов идут рука об руку;
- Тест-кейсы продолжают развиваться на основе наблюдений и обучения тестировщиков;
- К ET могут применяться различные методы тестирования, такие как анализ граничных значений, классы эквивалентности и т. д.;
- ET можно использовать сессионно , чтобы сделать его более структурированным и сфокусированным;
- Тестировщики могут развивать свои идеи, но никогда не отклоняться от своей миссии;
- Тестирование ET не использует сценарии, а зависит от интуиции, навыков и опыта тестировщика;

Туры в исследовательском тестировании: Чтобы систематизировать исследовательское тестирование можно использовать идею туров. 
Туры - это идеи и инструкции по исследованию программного продукта, объединенные определенной общей темой или целью. Туры, как правило, ограничены по времени - длительность тестовой сессии не должна превышать 4 часа.
Тур - это своего рода план тестирования, он отражает основные цели и задачи, на которых будет сконцентрировано внимание тестировщика во время сессии исследовательского тестирования. 
При этом Виттакер использует метафору, что тестировщик - это турист, а тестируемое приложение - это город. Обычно у туриста (тестировщика) мало времени, поэтому он выполняет конкретную задачу в рамках выбранного тура, ни на что другое не отвлекаясь. 
Город (ПО) разбит на районы: деловой центр, исторический район, район развлечений, туристический район, район отелей, неблагополучный район.

Что такое Дымовые (Smoke)/Ре-тест (Re-test)/ Санити (Sanity)/Регрессионное (Regression) тестирование?

Smoke-тестирование (или дымовое тестирование) — тестирование, проводимое на начальном этапе (например после нового билда), состоящее из минимального набора тестов, прохождение которых показывает, что продукт готов к дальнейшему тестированию. 
Идея данного вида тестирования заключается в том, чтобы выявить серьезные проблемы как можно раньше, и отклонить этот билд (вернуть на доработку) на раннем этапе тестирования, чтобы не углубляться в долгие и сложные тесты, не затрачивая тем самым время на заведомо бракованное ПО.

Санитарное тестирование –  вид тестирования сборки ПО после изменений в коде или функциональности. Его цель – проверить, что старые ошибки исправлены, а новых не появилось. 
Если Sanity-тест не проходит, сборка отправляется на доработку, а не на более тщательное тестирование.

Ретест — процедура повторной проверки отдельных тест-кейсов, при выполнении которых были обнаружены баги.

Регрессионное тестирование – вид тестирования программного обеспечения, подтверждающий, что недавнее изменение программы или кода не оказало негативного влияния на уже существующую функциональность. 
Для регрессионного тестирования выбирается полный или частичный набор уже использовавшихся ранее тест-кейсов, которые выполняются повторно, чтобы убедиться, что весь функционал работает нормально.

Что такое Тестирование нового функционала/ Приемочное тестирование?

Тестирование нового функционала – процесс проверки нового, добавляемого функционала ПО на соответствие предъявляемым к нему требованиям.

Цели:
- Минимизация рисков, связанных с наличием дефектов в работе новой функциональности программного обеспечения путем своевременного обнаружения этих дефектов в ходе тестирования.

Результаты:
- Информация о степени соответствия функциональности разработанного продукта требованиям, заявленным в документации.
- Информация о количестве дефектов во внедряемой функциональности и их критичности для работоспособности системы.
- Список дефектов с описанием проблем и способов их воспроизведения.

Приемочное тестирование (acceptance testing): Формальное тестирование по отношению к потребностям, требованиям и бизнес процессам пользователя, проводимое с целью определения соответствия системы критериям приемки и дать возможность пользователям, заказчикам или иным авторизованным лицам определить, принимать систему или нет. (IEEE 610)

После того, как процесс тестирования системы завершен командой тестирования, весь продукт передается клиенту и/или нескольким его пользователям для проверки приемлемости (acceptability). 
Е2Е бизнес-потоки проверяются аналогично в сценариях в реальном времени. Подобная производственной среда будет тестовой средой для приемочного тестирования (Staging, Pre-Prod, Fail-Over, UAT environment). 
Это метод тестирования черного ящика, при котором проверяется только функциональность, чтобы убедиться, что продукт соответствует указанным критериям приемки.

Виды приемочного тестирования:
* Пользовательское приемочное тестирование (UAT - User Acceptance Testing, validation, end-user testing) выполняется пользователем или клиентом чтобы определить, может ли ПО быть принято (accepted) или нет и проверить ПО на соответствие бизнес-требованиям. 
Могут существовать такие бизнес-требования и процессы, которые известны только конечным пользователям, и они либо пропускаются, либо неправильно интерпретируются, поэтому приемочное тестирование выполняется конечными пользователями, знакомыми с бизнес-требованиями;

* Бизнес - приемочное тестирование (BAT - Business Acceptance Testing) необходимо для оценки того, соответствует ли Продукт бизнес-целям и задачам. 
BAT в основном фокусируется на бизнес-преимуществах (финансах), которые являются довольно сложными из-за меняющихся рыночных условий / прогрессирующих технологий, так что текущая реализация может претерпеть изменения, которые приведут к дополнительным затратам. 
Даже Продукт, отвечающий техническим требованиям, может не пройти BAT по этим причинам;

* Контрактное приемочное тестирование (CAT - Contract Acceptance Testing) - это контракт, который определяет, что после того, как Продукт будет запущен в течение заранее определенного периода, должен быть проведен приемочный тест, и он должен пройти все приемочные тест-кейсы. 
Подписанный здесь контракт называется Соглашением об уровне обслуживания (SLA), которое включает условия, по которым платеж будет производиться только в том случае, если услуги Продукта соответствуют всем требованиям, что означает, что контракт выполнен. 
Иногда этот контракт может заключаться до того, как Продукт будет запущен. В любом случае, контракт должен быть четко определен с точки зрения периода тестирования, областей тестирования, условий по проблемам, возникающим на более поздних этапах, платежей и т. д.;

* Правовое приемочное тестирование (RAT - Regulations/Compliance Acceptance Testing) необходимо для оценки того, нарушает ли Продукт правила и нормы, установленные правительством страны, в которой он выпускается. 
Это может быть непреднамеренным, но отрицательно скажется на бизнесе. Обычно разрабатываемый Продукт / приложение, предназначенный для выпуска во всем мире, должен пройти RAT, поскольку в разных странах / регионах действуют разные правила и положения, определенные его руководящими органами. 
Если какие-либо правила и нормы нарушаются для какой-либо страны, то этой стране или конкретному региону в этой стране не будет разрешено использовать Продукт и это будет считаться отказом (Failure). 
Вендоры Продукта несут прямую ответственность, если Продукт будет выпущен даже при наличии нарушения;

* Эксплуатационное приемочное тестирование (OAT - Operational Acceptance testing) - это тип тестирования программного обеспечения, который оценивает эксплуатационную готовность программного приложения до его выпуска в производство. 
Целью эксплуатационного тестирования является обеспечение бесперебойной работы системы в ее стандартной эксплуатационной среде (SOE - standard operating environment). 
В основном это тестирование восстановления, совместимости, ремонтопригодности, доступности технической поддержки, надежности, восстановления после сбоя, локализации и т. д (recovery, compatibility, maintainability, technical support availability, reliability, fail-over, localization);

* Альфа-тестирование (Alpha Testing) проводят для оценки продукта в среде разработки / тестирования специализированной командой тестировщиков, обычно называемой альфа-тестерами. 
Здесь отзывы и предложения тестировщиков помогают улучшить использование Продукта, а также исправить определенные ошибки;

* Бета-тестирование, полевые испытания (Beta Testing, Field Testing) проводят для оценки Продукта, предоставляя его реальным конечным пользователям, обычно называемым бета-тестерами / бета-пользователями, в их среде. 
Собирается постоянная обратная связь от пользователей, и проблемы устраняются. Кроме того, это помогает в улучшении Продукта, чтобы обеспечить удобство работы пользователей. 
Тестирование происходит неконтролируемым образом, что означает, что у пользователя нет ограничений на использование Продукта;

Что такое Ручное/Автоматизированное/Полуавтоматизированное тестирование?

Ручное тестирование – это процесс, в котором тест-кейсы выполняются вручную, без помощи каких-либо средств автоматизации. Оно позволяет убедиться в том, что все функции приложения работают так, как заявлено в документации с требованиями. 
Поскольку при этом виде тестирования не используются никакие инструменты, оно является медленным, повторяющимся, дорогостоящим и занимает много времени.
В этом процессе тестировщики выполняют тестовые сценарии и создают отчеты о тестировании без помощи каких-либо инструментов автоматизации.

Плюсы ручного тестирования:
+ Пользовательский фидбек. Весь отчёт тестировщика может быть рассмотрен как обратная связь от потенциального пользователя.
+ UI-фидбек. В наше время пользовательский интерфейс играет огромную роль и поэтому полностью протестировать его можно только вручную.
+ Дешевизна. В краткосрочной перспективе ручное тестирование дешевле, чем инструменты автоматизированной проверки.
+ Тестирование в реальном времени. Незначительные изменения могут быть исследованы сразу, без написания кода и его исполнения.
+ Возможность исследовательского тестирования. Его целью является проверка разнообразных возможностей приложения. Важно, что используются не заранее составленные тест-кейсы, а придуманные на лету сценарии.

Минусы ручного тестирования:
- Человеческий фактор. Хотя UI и может быть протестирован только вручную, люди часто склонны к неэффективности. Некоторые ошибки могут остаться незамеченными.
- Трудоемкость повторного использование. Провести серию стандартных автоматических тестов проще, чем протестировать проект вручную после внесения даже небольших изменений.
- Невозможность проведения некоторых видов тестов, например, нагрузочного тестирования. Невозможно смоделировать большое количество пользователей вручную.

Автоматизированное тестирование – это метод, в котором используются инструменты для написания сценариев и выполнения тестовых примеров. 
Это лучший способ повысить скорость выполнения, эффективность и увеличить тестовое покрытие при тестировании программного обеспечения. Кроме того, это экономически выгодно и помогает быстро выявить возможные ошибки.
Организации внедряют автоматизацию тестирования с помощью фреймворка, который содержит стандарты, общие практики и инструменты тестирования. 
Хороший фреймворк для автоматизированного тестирования включает в себя стандарты кодирования, методы обработки тестовых данных, репозитории объектов, процедуры хранения результатов тестирования или детали использования внешних ресурсов.

Виды автоматизации тестирования
Существуют определенные тесты, которые должны быть автоматизированы. Вот некоторые из них:

* Юнит-тестирование (или модульное) – это процесс изолированной проверки отдельных частей программного обеспечения, т.е. функций, модулей, методов или классов. 
Оно помогает выявлять ошибки на ранних этапах разработки и снижает затраты. Кроме того, оно обеспечивает возможность повторного использования кода и помогает быстро перенести код и тесты в новый проект.

* Интеграционное тестирование позволяет выявить дефекты во взаимодействии нескольких модулей при их интеграции. Это можно сделать посредством тестирования API или на уровне пользовательского интерфейса приложения.

* Регрессионное тестирование: Это непрерывный процесс, проверяющий, правильно ли работают добавленные функции. Он гарантирует, что новая функция не вызовет каких-либо серьезных ошибок в уже имеющемся функционале, которые могут нарушить работу приложения.

* Тестирование производительности – это тестирование скорости, времени загрузки, стабильности и масштабируемости приложения. Оно гарантирует, что приложение работает в соответствии с требованиями.

* Тестирование безопасности заключается в проверке доступности приложения и его пользовательских данных. В рамках этого вида тестирования проводится несколько различных проверок, например, тестирование на проникновение, сканирование безопасности и т.д.

Преимущества:
+ Исключен «человеческий фактор» во время выполнения: тест-скрипт не допустит ошибки по неосторожности.
+ Скорость выполнения выше возможностей человека.
+ Автоматически формируемые и сохраняемые отчеты о результатах тестирования.
+ Выполнение в фоне – во время выполнения тестов можно заниматься другими задачами или выполнять тест-скрипты в нерабочее время.
+ Способность средств автоматизации выполнить тест-кейсы, в принципе непосильные для человека в силу своей сложности, скорости или иных факторов. Например, нагрузочное тестирование.

Недостатки:
- Необходим высококвалифицированный персонал в силу того факта, что автоматизация — это «проект внутри проекта» (со своими требованиями, планами, кодом и т.д.).
- Высокие затраты на сложные средства автоматизации, разработку и сопровождение кода тест-кейсов.
- Автоматизация требует более тщательного планирования и управления рисками, т.к. в противном случае проекту может быть нанесен серьезный ущерб.
- Средств автоматизации крайне много, что усложняет проблему выбора того или иного средства и может повлечь за собой финансовые затраты (и риски), необходимость обучения персонала (или поиска специалистов).
- В случае ощутимого изменения требований, смены технологического домена, переработки интерфейсов (как пользовательских, так и программных) многие тест-кейсы становятся безнадежно устаревшими и требуют создания заново.

Смешанное/полуавтоматизированное тестирование
Здесь ручной подход сочетается с автоматизированным. Например, с помощью программы создается новый аккаунт, а потом вручную генерируются транзакции покупки.

На основании чего происходит разработка тестовых сценариев?
Тестовый сценарий (Test scenario) - последовательность действий над продуктом, которые связаны единым ограниченным бизнес-процессом использования, и сообразных им проверок корректности поведения продукта в ходе этих действий. Иными словами, это последовательность шагов, которые пользователь может предпринять, чтобы использовать ваше программное обеспечение. Сценарии тестирования должны учитывать все возможные способы выполнения задачи (функции) и охватывать как положительные, так и отрицательные тестовые примеры, потому что конечные пользователи могут не обязательно предпринимать шаги, которые вы от них ожидаете. Используя тестовые сценарии, мы оцениваем работу приложения с точки зрения конечного пользователя. Фактически при успешном прохождении всего тестового сценария мы можем сделать заключение о том, что продукт может выполнять ту или иную возложенную на него функцию.

Как писать сценарии:
1. Тщательно ознакомьтесь с требованиями (Спецификация бизнес-требований (BRS), Спецификация требований к программному обеспечению (SRS), Спецификация функциональных требований (FRS)) тестируемой системы (SUT), use cases, книгами, руководствами и т. д.;
2. Для каждого требования выясните, как пользователь может использовать программное обеспечение всеми возможными способами;
3. Составьте список сценариев тестирования для каждой функции тестируемого приложения (AUT);
4. Создайте матрицу прослеживаемости и свяжите все сценарии с требованиями. Это позволит вам определить, сопоставлены ли все требования с тестовыми сценариями или нет;
5. Отправьте сценарии тестирования руководителю, чтобы он рассмотрел и оценил их. Даже сценарии тестирования дополнительно проверяются всеми заинтересованными сторонами.

Что такое Frontend / Backend?

Фронтендом (англ. front-end) называют клиентскую сторону пользовательского интерфейса по отношению к программно-аппаратной части сервиса.
Говоря простым языком, frontend — это разработка функциональности и пользовательского интерфейса, работающих на клиентской стороне приложения или веб-сайта. 
Сюда относят всё, что пользователь видит, открывая веб-страницу. Для создания удобного и востребованного продукта фронтенд-разработчики сотрудничают с программистами, дизайнерами, UX-аналитиками.


Бэкенд (англ. back-end) — это программно-аппаратная часть сервиса. Это набор средств, с помощью которых происходит реализация логики веб-сайта. Это то, что скрыто от наших глаз, т. е. происходит вне компьютера и браузера.
Как только вы введете запрос на странице поисковика и нажмете клавишу «Ввод», frontend закончится и начнётся backend. Ваш запрос отправится на сервер Яндекса или Google, т. е. по месту расположения алгоритмов поиска. 
Именно там и происходит вся «магия». Но вот, на мониторе появляются данные, которые вы запрашивали, — это происходит возвращение во frontend.
Также можно сказать, что backend — это процесс объединения пользователя с сервером.

Что такое тестирование безопасности?
Перечислите Принципы безопасности программного обеспечения
Перечислите виды уязвимостей в безопасности программного обеспечения.

Это тип тестирования ПО, который выявляет уязвимости, угрозы и риски. 
Целью тестов безопасности является выявление всех возможных лазеек и слабых мест в ПО, которые могут привести к потере информации, доходов, репутации компании, сотрудников или клиентов. 

Общая стратегия безопасности основывается на трех основных принципах:

- Конфиденциальность - сокрытие определенных ресурсов или информации;
- Целостность - ресурс может быть изменен только в соответствии с полномочиями пользователя;
- Доступность - ресурсы должны быть доступны только авторизованному пользователю, внутреннему объекту или устройству;

Типы тестирования безопасности:

- Сканирование уязвимостей/оценка защищенности (Vulnerability Scanning) выполняется с помощью автоматизированного ПО для сканирования системы на наличие известных сигнатур уязвимостей;

- Сканирование безопасности (Security Scanning) включает в себя выявление слабых сторон сети и системы, а затем предоставляет решения для снижения этих рисков. Это сканирование может быть выполнено как вручную, так и автоматизированно;

- Тестирование на проникновение (Penetration testing) имитирует атаку злоумышленника. Это тестирование включает анализ конкретной системы для проверки потенциальных уязвимостей при попытке внешнего взлома;

- Оценка рисков (Risk Assessment) включает анализ рисков безопасности, наблюдаемых в организации. Риски классифицируются как Низкие, Средние и Высокие. Это тестирование рекомендует меры по снижению риска;

- Аудит безопасности (Security Auditing) - внутренняя проверка приложений и операционных систем на наличие уязвимостей. Аудит также может быть выполнен путем построчной проверки кода;

- Этический взлом (Ethical hacking) - совершается с целью выявления проблем безопасности в системе. Это делается White Hat хакерами - это специалисты по безопасности, которые использует свои навыки законным способом для помощи в выявлении уязвимостей системы, в отличии от Black Hat (преступников);

- Оценка состояния (Posture Assessment) объединяет сканирование безопасности, этический взлом и оценки рисков, чтобы показать общее состояние безопасности организации;


В настоящее время наиболее распространенными видами уязвимости в безопасности программного обеспечения являются:

- XSS (Cross-Site Scripting) - это вид уязвимости программного обеспечения (Web приложений), при которой, на генерированной сервером странице, выполняются вредоносные скрипты, с целью атаки клиента.

- XSRF / CSRF (Request Forgery) - это вид уязвимости, позволяющий использовать недостатки HTTP протокола, при этом злоумышленники работают по следующей схеме: ссылка на вредоносный сайт устанавливается на странице, пользующейся доверием у пользователя, при переходе по вредоносной ссылке выполняется скрипт, сохраняющий личные данные пользователя (пароли, платежные данные и т.д.), либо отправляющий СПАМ сообщения от лица пользователя, либо изменяет доступ к учетной записи пользователя, для получения полного контроля над ней.

- Code injections (SQL, PHP, ASP и т.д.) - это вид уязвимости, при котором становится возможно осуществить запуск исполняемого кода с целью получения доступа к системным ресурсам, несанкционированного доступа к данным либо выведения системы из строя.

- Server-Side Includes (SSI) Injection - это вид уязвимости, использующий вставку серверных команд в HTML код или запуск их напрямую с сервера.

- Authorization Bypass - это вид уязвимости, при котором возможно получить несанкционированный доступ к учетной записи или документам другого пользователя

Что такое Тестирование на отказ и восстановления Failover and Recovery Testing?

Тестирование на отказ и восстановление (Failover and Recovery Testing) проверяет тестируемый продукт с точки зрения способности противостоять и успешно восстанавливаться после возможных сбоев, возникших в связи с ошибками программного обеспечения, отказами оборудования или проблемами связи (например, отказ сети). 
Целью данного вида тестирования является проверка систем восстановления (или дублирующих основной функционал систем), которые, в случае возникновения сбоев, обеспечат сохранность и целостность данных тестируемого продукта.

Тестирование на отказ и восстановление очень важно для систем, работающих по принципу “24x7”. Если Вы создаете продукт, который будет работать, например в интернете, то без проведения данного вида тестирования Вам просто не обойтись. 
Т.к. каждая минута простоя или потеря данных в случае отказа оборудования, может стоить вам денег, потери клиентов и репутации на рынке.

Методика подобного тестирования заключается в симулировании различных условий сбоя и последующем изучении и оценке реакции защитных систем. 
В процессе подобных проверок выясняется, была ли достигнута требуемая степень восстановления системы после возникновения сбоя.

Объектом тестирования в большинстве случаев являются весьма вероятные эксплуатационные проблемы, такие как:
- Отказ электричества на компьютере-сервере
- Отказ электричества на компьютере-клиенте
- Незавершенные циклы обработки данных (прерывание работы фильтров данных, прерывание синхронизации).
- Объявление или внесение в массивы данных невозможных или ошибочных элементов.
- Отказ носителей данных.

Технически реализовать тесты можно следующими путями:
- Симулировать внезапный отказ электричества на компьютере (обесточить компьютер).
- Симулировать потерю связи с сетью (выключить сетевой кабель, обесточить сетевое устройство)
- Симулировать отказ носителей (обесточить внешний носитель данных)
- Симулировать ситуацию наличия в системе неверных данных (специальный тестовый набор или база данных).

При достижении соответствующих условий сбоя и по результатам работы систем восстановления, можно оценить продукт с точки зрения тестирования на отказ. 
Во всех вышеперечисленных случаях, по завершении процедур восстановления, должно быть достигнуто определенное требуемое состояние данных продукта:
- Потеря или порча данных в допустимых пределах.
- Отчет или система отчетов с указанием процессов или транзакций, которые не были завершены в результате сбоя.

Что такое тестирование Эффективности использования ресурсов?

Тестирование эффективности использования ресурсов — это процесс проверки программного обеспечения на предмет того, как оно использует системные ресурсы, такие как процессор, память, дисковое пространство и сетевую пропускную способность. 
Цель этого вида тестирования заключается в определении возможных проблем с производительностью, которые могут возникнуть при использовании ПО, и устранении их для оптимизации работы системы.

Тестирование эффективности использования ресурсов важно по множеству причин. 
Во-первых, оно помогает обнаружить и устранить узкие места в производительности, которые могут привести к задержкам или сбоям в работе приложения. 
Во-вторых, оптимизация использования ресурсов может сэкономить средства на оборудовании и снизить затраты на энергию. 
В-третьих, улучшение производительности может увеличить удовлетворенность пользователей, что в свою очередь способствует росту и успеху продукта.

Процесс тестирования эффективности использования ресурсов состоит из следующих этапов:
1. Планирование: на этом этапе определяются цели тестирования, выбираются инструменты и методы, а также разрабатывается план тестирования.
2. Сбор данных: сбор информации о системных ресурсах, используемых программным обеспечением, путем мониторинга и анализа.
3. Анализ данных: оценка полученной информации для выявления проблем с производительностью и определение возможных путей их решения.
4. Оптимизация: внедрение изменений в программное обеспечение для улучшения эффективности использования ресурсов.
5. Повторное тестирование: проверка результатов оптимизации, сравнение с показателями до оптимизации и оценка достижения поставленных целей.

Пример 1: Использование профилировщика памяти для выявления утечек памяти и определения неэффективного использования памяти в приложении.
Пример 2: Тестирование сетевой производительности приложения для определения задержек и пропускной способности, а также выявления потенциальных проблем с масштабируемостью.
Пример 3: Использование нагрузочного тестирования для определения времени отклика приложения при различных уровнях нагрузки и выявления возможных проблем с производительностью.

Что такое тестирование Масштабируемости (Scalability testing)?

Тестирование масштабируемости проводится для определения способности приложения масштабироваться с точки зрения пользовательской нагрузки, количества транзакций, объема данных и т. д. 

Цель теста масштабируемости отличается от стрессового или нагрузочного тестирования. Например, компания ожидает шестикратного увеличения нагрузки на серверы в течение следующих двух месяцев. 
Им может потребоваться увеличить производительность сервера и сократить время обработки запроса, чтобы лучше обслуживать посетителей. 
Если приложение масштабируемое, вы можете сократить это время, обновив оборудование сервера, например, вы можете увеличить частоту ЦП и добавить больше ОЗУ. 
Также вы можете улучшить производительность запросов, изменив программное обеспечение сервера, например, заменив хранилища данных в текстовых файлах базами данных SQL Server. 
Чтобы найти лучшее решение, вы можете сначала протестировать изменения оборудования, затем изменения программного обеспечения, а затем сравнить результаты тестов.

Пример: если тестирование масштабируемости определяет максимальную нагрузку в 10 000 пользователей, то для обеспечения масштабируемости системы разработчикам необходимо принять меры по таким факторам, как уменьшение времени отклика после достижения лимита в 10 000 пользователей или увеличение размера ОЗУ для соответствия растущему количеству пользовательских данных.

Что такое тестирование Производительности (Performance testing)?

Тестирование производительности - это нефункциональный вид тестирования программного обеспечения, используемый для проверки скорости, времени отклика, стабильности, надежности, масштабируемости и использования ресурсов программного приложения при определенной рабочей нагрузке, обычно регрессионным образом, когда в приложение ежедневно или еженедельно вносятся небольшие изменения. 
Обычно продолжительность теста производительности составляет 1 час (устойчивое состояние) на средней / ожидаемой нагрузке; это может варьироваться в зависимости от вашего SLA / требований.

Цели данного вида тестирования:
- Измерить время отклика самых важных бизнес-транзакций;
- Определить предельный уровень допустимой нагрузки;
- Выявить «узкие» места в производительности системы;
- Составить рекомендации по улучшению производительности;
- Найти возможные дефекты, проявляющиеся только при одновременной работе большого количества пользователей.

Тестирование производительности проводится для того, чтобы убедиться, что приложение работает достаточно быстро, чтобы удерживать внимание и интерес пользователя. 
Список распространенных проблем с производительностью, где видно,  что скорость является общим фактором во многих из них:

- Длительное время загрузки - обычно время загрузки - это начальное время, необходимое приложению для запуска. 
Обычно оно должно быть сведено к минимуму. Хотя некоторые приложения невозможно загрузить менее чем за минуту, время загрузки должно быть меньше нескольких секунд, если это возможно;

- Плохое время отклика. Время отклика - это время, которое проходит с момента ввода пользователем данных в приложение до того, как приложение выдаст ответ на этот ввод. 
Как правило, это должно происходить очень быстро. Опять же, если пользователю приходится ждать слишком долго, он теряет интерес;

- Плохая масштабируемость - программный продукт страдает от плохой масштабируемости, когда он не может обрабатывать ожидаемое количество пользователей.

Узкие места (Bottlenecking)- это препятствия в системе, которые ухудшают общую производительность системы. 
Узкое место - это либо ошибки в коде, либо проблемы с оборудованием, которые вызывают снижение пропускной способности при определенных нагрузках. 
Узкие места обычно устраняются путем исправления плохо работающих процессов или добавления дополнительного оборудования. Некоторые общие узкие места производительности:
- Загрузка ЦП;
- Использование памяти;
- Использование сети;
- Ограничения операционной системы;
- Использование диска;

Как проводить тестирование производительности?

1. Определить необходимую среду тестирования (testing environment): перед тем, как начать процесс тестирования, изучите детали аппаратного, программного обеспечения и сетевых конфигураций, используемых во время тестирования. 
Это поможет тестировщикам создавать более эффективные тесты. Это также поможет определить возможные проблемы, с которыми тестировщики могут столкнуться во время процедур тестирования производительности;

2. Определить критерии приемки: сюда входят цели и ограничения по пропускной способности, времени отклика и распределению ресурсов. Также необходимо определить критерии успеха проекта, выходящие за рамки этих целей и ограничений. 
Тестировщики должны иметь право устанавливать критерии и цели производительности, потому что часто спецификации проекта не включают достаточно широкий спектр тестов производительности. Иногда их может и вовсе не быть. 
Если возможно, найти похожее приложение для сравнения - это хороший способ установить цели производительности;

3. Планирование и проектирование тестов производительности: Определить, как использование может варьироваться среди конечных пользователей, и определите ключевые сценарии для тестирования всех возможных вариантов использования. 
Необходимо смоделировать различных конечных пользователей, спланировать данные тестирования производительности и наметить, какие метрики будут собраны;

4. Настройка тестовой среды: Подготовьте тестовую среду перед выполнением. Также подготовьте инструменты и другие ресурсы;

5. Имплементирование тест-дизайна: Создайте тесты производительности в соответствии с вашим тест-дизайном;

6. Запуск тестов: Выполнить и промониторить тесты;

7. Анализ, настройка и повторное тестирование: объединяйте, анализируйте и делитесь результатами тестирования. Затем  точную настройка и снова проверка, есть ли улучшение или снижение производительности. 
Поскольку улучшения обычно становятся меньше с каждым повторным тестом, остановитесь, когда узкое место вызвано ЦП. Тогда вы можете рассмотреть вариант увеличения мощности процессора.

Метрики тестирования производительности (Performance Testing Metrics):

- Использование процессора (Processor Usage): время, затрачиваемое процессором на выполнение non-idle потоков;
- Использование памяти (Memory use): объем физической памяти, доступной процессам на компьютере;
- Время диска (Disk time): время, в течение которого диск занят выполнением запроса на чтение или запись;
- Время отклика (Response time): время с момента ввода пользователем запроса до получения первого символа ответа. Подробнее: раз, два;
- Задержка (Latency): временной интервал между запросом и ответом;
- Пропускная способность (Throughput): фактическое количество запросов (или пользователей), которое может обработать система за определенное время. 
  В то время как время задержки говорит вам только о времени, метрика пропускной способности информирует об объеме данных, полученных и обработанных в момент времени. 
  Важно не отделять показатели времени задержки от пропускной способности, т.к. высокий показатель времени задержки часто прямо связан с увеличением показателей метрики пропускной способности. 
  Пропускная способность обычно измеряется в rps - (кол-во) запросов в секунду (requests per second).

- Ширина пропускания канала (Bandwidth): максимальное число запросов (или пользователей), которое может обработать система. В отличие от пропускной способности ширина пропускания канала измеряет максимальный объем, который может обработать приложение.
- Частные байты (Private bytes): количество байтов, выделенных процессом, которые не могут использоваться другими процессами. Они используются для измерения утечек и использования памяти;
- Выделенная память (Committed memory) - объем используемой виртуальной памяти;
- Страниц памяти в секунду (Memory pages/second) - количество страниц, записываемых на диск или считываемых с диска для устранения аппаратных ошибок страниц. Сбои аппаратной страницы - это когда код не из текущего рабочего набора вызывается из другого места и извлекается с диска;
- Ошибок страниц в секунду (Page faults/second) - общая скорость, с которой страницы ошибок обрабатываются процессором. Это происходит, когда процессу требуется код из-за пределов своего рабочего набора;
- Число прерываний процессора в секунду (CPU interrupts per second): это среднее количество аппаратных прерываний, которые процессор принимает и обрабатывает каждую секунду;
- Длина дисковой очереди (Disk queue length): среднее количество запросов на чтение и запись, поставленных в очередь для выбранного диска в течение интервала выборки;
- Длина сетевой выходной очереди (Network output queue length): длина очереди выходных пакетов в пакетах. Значение больше двух означает, что необходимо убрать задержку и возникновение узких мест;
- Всего сетевых байтов в секунду (Network bytes total per second): скорость, с которой байты отправляются и принимаются интерфейсом, включая символы кадрирования;
- Количество пулов соединений (Amount of connection pooling): количество запросов пользователей, которые удовлетворяются объединенными соединениями. Чем больше запросов будет выполнено подключениями в пуле, тем выше будет производительность;
- Максимальное количество активных сессий (Maximum active sessions): максимальное количество сессий, которые могут быть активны одновременно;
- Коэффициент хитов (Hit ratios): это связано с количеством операторов SQL, которые обрабатываются кэшированными данными вместо дорогостоящих операций ввода-вывода. Это хорошее начало для решения проблем, связанных с узкими местами;
- Хитов в секунду (Hits per second): количество хитов веб-сервера в течение каждой секунды нагрузочного теста;
- Сегмент отката (Rollback segment): объем данных, который можно откатить в любой момент времени;
- Блокировки баз данных (Database locks) - блокировки таблиц и баз данных необходимо отслеживать и тщательно настраивать;
- Максимальное время ожидания (Top waits) - отслеживаются, чтобы определить, какое время ожидания можно сократить при работе с тем, насколько быстро данные извлекаются из памяти;
- Количество потоков (Thread counts): состояние приложения можно измерить по количеству потоков, которые работают и в настоящее время активны;
- Сборка мусора (Garbage collection): это связано с возвратом неиспользуемой памяти обратно в систему. Сборку мусора необходимо отслеживать на предмет эффективности;

Тестирование производительности клиентской части и серверной, в чем разница?

Оценка скорости работы клиентской и серверной частей веб-приложения осуществляется двумя разными видами тестирования: для Frontend применяется тестирование клиентской части, или Client-Side testing, а для Back-end - тестирование серверной части.
Основная цель тестирования клиентской части состоит в измерении времени, необходимого браузеру для загрузки HTML-страницы. Наиболее важными показателями здесь являются количество загружаемых данных, их объем, а также количество выполненных запросов.
Собрать данную статистику можно как с использованием встроенных инструментов браузера (DevTools), так и с помощью специализированных инструментов и онлайн-сервисов, которые позволяют измерить необходимые показатели с учетом интересующего региона.
Помимо общего веса страницы, инструменты предоставляют детализированную информацию по каждому из компонентов. Изучив параметры запросов, можно обнаружить ряд проблем, приводящих к ухудшению скорости отображения страницы. К примеру, подгружается слишком большая картинка, медленный Javascript, или отправляется значительное количество запросов.
Другая необходимая проверка направлена на анализ заголовков кэширования, поскольку корректность его выполнения при повторном посещении страницы позволяет повысить скорость загрузки страницы до 80%.
Тестирование серверной части направлено на анализ выполнения запросов и получения соответствующего ответа от Back-end.

Что такое тестирование Надежности(Reliability Testing)?

Надежность (reliability): Способность программного продукта функционировать при заданных условиях на протяжении определенного периода времени, или для определенного количества операций. (ISO 9126)

Надежность (Reliability) - это «вероятность безотказной работы программного обеспечения в течение определенного периода времени в определенной среде», т.е. это результат, к которому стремятся разработчики, способом достижения которого является устойчивость. Тестирование надежности связано с качеством программного обеспечения и стандартизацией продуктов. Если мы можем повторять тест-кейсы и постоянно получать один и тот же результат, то продукт считается «надежным». Тестирование надежности выполняется, чтобы убедиться, что программное обеспечение надежно, соответствует цели, для которой оно создано, и в течение определенного периода времени в данной среде способно обеспечить безотказную работу. Тестирование надежности может включать в себя Feature Testing, Security testing, Load Testing, Regression Testing и др.

Основные варианты для оценки надежности:
- Надежность повторного тестирования (Test-retest Reliability): при тестировании функционала одинаковыми тест-кейсами в разное время каждый раз мы получаем высокую корреляцию результатов. 
Тогда мы можем сказать, что тест «надежен». Обычно надежность 0,8 или более означает, что систему можно рассматривать как высоконадежный продукт;

- Параллельная или альтернативная форма надежности (Parallel or Alternate form of Reliability): разные версии одного теста должны давать одинаковый результат;

- Надежность между оценщиками (Inter-Rater Reliability): Надежность между оценщиками иначе известна как надежность между наблюдателями (Inter-Observer) или кодировщиками (Inter-Coder). 
Это особый тип надежности, состоящий из нескольких оценщиков или судей. Он касается согласованности рейтинга, выставляемого разными оценщиками / наблюдателями;

План тестирования надежности:

Имея правильную модель, мы можем предсказать качество продукта. 
К двум типам моделей относятся:
- Модель прогноза (Prediction Model): В прогнозном тестировании (Predictive testing) мы прогнозируем результат на основе исторических данных, статистики, машинного обучения. 
Все, что нам нужно, это написать отчет. В прогнозной модели мы получаем только некоторую историческую информацию. Используя эту информацию, мы можем экстраполировать имеющиеся данные на будущее;

- Модель оценки (Estimation Model): Этот тип модели выполняется перед самой стадией разработки или тестирования. 
В оценочном тестировании (Estimation Testing), помимо использования исторических данных, мы будем использовать текущие данные. 
Здесь мы можем спрогнозировать надежность продукта в настоящее время или в будущем. Этот тип тестирования выполняется на последних этапах жизненного цикла разработки программного обеспечения.

Что такое тестирование Стабильности (Stability Testing)?

Тестирование износостойкости (endurance testing): Тип тестирования уровня производительности для определения того, может ли элемент тестирования постоянно выдерживать требуемую нагрузку в течение установленного периода времени.
Тестирование на выносливость (Endurance Testing, оно же Stability Testing, Soak Testing, Longevity Testing) включает в себя тестирование системы со значительной нагрузкой в ​​течение длительного периода времени, чтобы выяснить, как система ведет себя при длительном использовании. То есть для обеспечения того, чтобы производительность и / или время отклика после некоторого длительного периода устойчивой активности были не хуже, чем в начале теста. В основном используется для проверки утечек памяти, времени отклика, правильности подключения и закрытия подключения к модулям (например, БД) и т.п. Обычно продолжительность испытания на выносливость составляет 6-8 часов; может отличаться в зависимости от вашего SLA / требований.

Пример: если тестирование масштабируемости определяет максимальную нагрузку в 10 000 пользователей, то для обеспечения масштабируемости системы разработчикам необходимо принять меры по таким факторам, как уменьшение времени отклика после достижения лимита в 10 000 пользователей или увеличение размера ОЗУ для соответствия растущему количеству пользовательских данных.

Что такое тестирование Удобства использования(Usability testing)?

Тестирование удобства пользования - это нефункциональный вид тестирования программного обеспечения, являющийся подмножеством тестирования пользовательского опыта - UX, “Ю-Экс”, user experience. 
В целом оно подразделяется на 
- понятность, 
- обучаемость, 
- работоспособность, 
- привлекательность 
- и соответствие (understandability, learnability, operability, attractiveness, and compliance). 

Юзабилити-тестирование предназначено для определения того, насколько программный продукт понятен, легок в освоении, прост в эксплуатации и привлекателен для пользователей при определенных условиях и требованиях. 
Этот тип тестирования обычно выполняется реальными пользователями.

Категории юзабилити-тестирования:
- Исследовательская: обычно мы рассматриваем эту категорию на ранних этапах процесса тестирования программного обеспечения. Чем раньше выполняется тестирование юзабилити в процессе тестирования, тем меньше риски в продукте. 
На этом этапе обычно рассматривается дизайн продукта и концепции, относящиеся к продукту или услуге;

- Оценочная: эта категория описывает оценку выполнения Е2Е теста, а также анализирует эффективность продукта и удовлетворенность пользователей;

- Сравнительная: в этой категории два или более схожих продукта сравниваются по разным атрибутам, таким как дизайн продукта, преимущества и недостатки, что помогает выбрать продукт, который обеспечивает лучший пользовательский опыт;

Методы юзабилити-тестирования:
* Промежуточное (? hallway) тестирование. Этот метод является одним из наиболее эффективных и экономичных по сравнению с другими доступными методами. 
При использовании этого метода веб-сайт или продукт для тестирования получают несколько случайных людей, а не обученные специалисты. 
Поскольку случайные люди тестируют службу без предварительного знания продукта, они тестируют ее более эффективно и предоставляют более точные результаты и честную обратную связь для улучшения, если таковые имеются;

* Удаленное тестирование. Как следует из названия, удаленное тестирование юзабилити проводится людьми, которые находятся в удаленных местах. 
Обратная связь может быть записана и отправлена ​​случайными людьми, а не экспертом по технологиям. Иногда удаленное тестирование выполняется с помощью видеоконференцсвязи. 
Этот тип юзабилити-тестирования снижает стоимость по сравнению с другими типами тестирования;

* Экспертная оценка. Эксперта в данной области просят протестировать продукт или услугу и предоставить отзыв, а затем представить результаты. Обычно это быстро, но и стоит дорого. 
Эксперт находит лазейки и обнаруживает недостатки в продукте или услуге;

* Бумажный прототип. Тестирование бумажных прототипов - один из самых традиционных подходов к тестированию юзабилити. Этот метод включает в себя пробный запуск теста, ручной набросок, рисование моделей или прототипа. 
Обсуждение последовательности операций и их рисование на бумаге, а также рассмотрение всех возможных исходных данных, сценариев и условий - вот цель этого типа тестирования. 
Это один из основных типов тестирования, который чаще всего применяется во всех проектах для устранения основных проблем. Выполняя тестирование бумажного прототипа, можно получить больше ясности в процессе выполнения. 
Тестирование бумажного прототипа обычно проводится в проектной группе. Следовательно, это рассматривается на ранних этапах процесса тестирования. 
Это относительно более дешевый метод тестирования юзабилити, но не самый эффективный способ тестирования, поскольку он временами занимает больше времени, и существует более высокая вероятность того, что даже после тестирования мы можем пропустить несколько проблем;

* Автоматизированное. Как следует из названия, этот метод тестирования выполняется путем написания сценариев автоматизации. После выполнения теста результаты записываются и отправляются. 

Тестирование удобства пользования дает оценку уровня удобства использования приложения по следующим пунктам:
- производительность, эффективность (efficiency) - сколько времени и шагов понадобится пользователю для завершения основных задач приложения, например, размещение новости, регистрации, покупка и т. д.? (меньше - лучше)
- правильность (accuracy) - сколько ошибок сделал пользователь во время работы с приложением? (меньше - лучше)
- активизация в памяти (recall) - как много пользователь помнит о работе приложения после приостановки работы с ним на длительный период времени? (повторное выполнение операций после перерыва должно проходить быстрее чем у нового пользователя)
- эмоциональная реакция (emotional response) - как пользователь себя чувствует после завершения задачи - растерян, испытал стресс? Порекомендует ли пользователь систему своим друзьям? (положительная реакция - лучше)

Проверка удобства использования может проводиться как по отношению к готовому продукту, посредством тестирования черного ящика (black box testing), так и к интерфейсам приложения (API), используемым при разработке - тестирование белого ящика (white box testing). В этом случае проверяется удобство использования внутренних объектов, классов, методов и переменных, а также рассматривается удобство изменения, расширения системы и интеграции ее с другими модулями или системами. Использование удобных интерфейсов (API) может улучшить качество, увеличить скорость написания и поддержки разрабатываемого кода, и как следствие улучшить качество продукта в целом.
Отсюда становится очевидно, что тестирование удобства пользования может производиться на разных уровнях разработки ПО: модульном, интеграционном, системном и приемочном.

Что такое тестирование Локализации// Совместимости/ Адаптивности?

Тестирование доступности (accessibility testing): Тестирование, которое определяет степень легкости, с которой пользователи с ограниченными способностями могут использовать систему или ее компоненты (ISTQB).
Тестирование доступности (accessibility testing) - это подмножество юзабилити-тестирования. Его цель - убедиться в том, что наш продукт удобен в использовании людям с различными видами ограничений, инвалидности или особенностями восприятия. 
Это могут быть проблемы со зрением, слухом или ограничения в подвижности рук. Что наиболее важно, существуют определенные законы и инструкции по тестированию доступности, которые также должны соблюдаться, например, Рекомендации по доступности веб-контента (Web content accessibility guidelines). Продукт должен правильно работать с соответствующим ПО.

Примеры такого программного обеспечения:

- Speech Recognition Software - ПО преобразует произнесенное слово в текст, который служит вводом для компьютера;
- Программа для чтения с экрана - используется для озвучивания текста, отображаемого на экране;
- Программное обеспечение для увеличения экрана - используется для увеличения масштаба элементов и облегчения чтения для пользователей с нарушениями зрения;
- Специальная клавиатура, облегчающая ввод для пользователей, у которых проблемы с двигательными функциями;

Что такое ETL-тестирование/Тестирование перед миграцией (Pre-Migration testing)/Миграционное тестирование (Migration testing)/Тестирование после миграции (Post-Migration testing)?

ETL (Extract, Transform, Load) - это процесс, объединяющий три этапа: извлечение, преобразование и загрузка данных из одного источника в другой, т.е. процесс перемещения данных из одного места в другое, из одного формата в другой или из одного приложения в другое. Как правило, это результат внедрения новой системы или места хранения данных. Бизнес-драйвером обычно является миграция или консолидация приложений, при которых устаревшие системы заменяются или дополняются новыми приложениями, использующими тот же набор данных.
Миграция часто начинается, когда компании переходят от локальной инфраструктуры и приложений к облачным хранилищам и приложениям для оптимизации или преобразования своего бизнеса.
ETL-тестирование - это вид тестирования, выполняемый для гарантии того, что данные, перенесенные из исходной в целевую базу данных, являются точными и соответствуют действующим правилам преобразования.

Пример:
Давайте рассмотрим пример слияния двух компаний - компании A и компании B. После слияния их операции будут объединены, а их клиенты, сотрудники и другие данные будут храниться в единой централизованной базе данных. Предположим, что компания A использует базу данных Oracle для хранения всей информации, а компания B использует MySQL. Теперь для объединения своей информации обе компании могут использовать процесс ETL для переноса данных из своих отдельных баз данных в одну согласованную базу данных. В процессе ETL, поскольку две базы данных различны, данные обеих компаний будут в разном формате, будут использоваться разные соглашения об именах, будут использоваться разные структуры таблиц и так далее. Из-за этих различий компаниям необходимо удостовериться, что перед загрузкой данных в целевую базу данных она была должным образом очищена и может сформировать нужный формат. При тестировании ETL тестировщики должны убедиться, что:
данные обеих баз данных были преобразованы в формат целевой базы данных;
необходимые функции преобразования были выполнены;
в процессе не было потеряно никаких данных, и данные являются точными.

Миграция состоит из 7 этапов:
1. Premigration planning: Оценить перемещаемые данные на предмет стабильности;
2. Project initiation: Определить и проинструктировать ключевых лиц, принимающих решения;
3. Landscape analysis: Создайте надежный процесс управления правилами качества данных и проинформируйте бизнес о целях проекта, включая отключение устаревших систем;
4. Solution design: Определите, какие данные необходимо переместить, а также качество этих данных до и после перемещения.
5. Build & test: Закодируйте логику миграции и протестируйте миграцию с копией рабочей среды.
6. Execute & validate: Продемонстрируйте, что миграция соответствует требованиям и что перемещенные данные пригодны для использования в бизнесе.
7. Decommission & monitor: Выключите и утилизируйте старые системы.

Как разработать стратегию тестирования переноса данных?
Учитывая эту сложность, точное тестирование должно начинаться задолго до фактического переноса данных, чтобы обеспечить необходимый уровень осведомленности и ресурсов. 
Чтобы гарантировать, что проект получит необходимое ему внимание, сосредоточьтесь на самом провокационном элементе миграции - на том факте, что устаревшая система будет отключена. Надежная стратегия тестирования обязательна!

Следовательно, этапы стратегии тестирования теста миграции, которые будут проводиться , могут быть классифицированы как Pre-Migration Testing; Migration Testing; Post Migration Testing.

Тестирование перед миграцией (Pre-Migration testing)
Вот действия, которые предпринимаются на этом этапе:

1. Установите четкий объем данных - какие данные должны быть включены, какие данные должны быть исключены, какие данные требуют преобразования/конвертации и т. д.;
2. Выполнение сопоставление данных (data mapping) между устаревшим и новым приложением - для каждого типа данных в устаревшем приложении сравните соответствующий тип в новом приложении, а затем сопоставьте их - Сопоставление более высокого уровня (Higher level mapping);
3. Изучите схему данных нового приложения - имена полей, типы, минимальные и максимальные значения, длину, обязательные поля, проверки на уровне полей и т. д.;
4. Изучите интерфейсы в новом приложении и их подключения. Данные, проходящие через интерфейс, должны быть надежно защищены и настроены;
5. Подготовьте тестовые случаи, тестовые сценарии и используйте их для новых условий в новых приложениях;
6. Выполните набор тестовых случаев с набором пользователей и сохраните результаты, журналы. То же самое необходимо проверить после того, как произошла миграция, чтобы убедиться, что устаревшие данные и функциональность не повреждены;
7. Количество данных и записей должно быть четко записано, его необходимо проверить после миграции, чтобы доказать, что никакие данные не были потеряны.

Миграционное тестирование (Migration testing)

В идеале миграция начинается с резервного копирования данных на ленту, чтобы в любой момент можно было восстановить устаревшую систему. Все сценарии и шаги должны быть правильно задокументированы без какой-либо двусмысленности.

Запись фактического времени, затраченного на миграцию с момента начала миграции до успешного восстановления системы, является одним из тестовых случаев, которые необходимо выполнить, и, следовательно, «Время, необходимое для миграции системы», должно быть записано в final test report, который будет предоставлен как часть результатов миграционного тестирования, и эта информация будет полезна во время запуска в прод. 
Время простоя, записанное в тестовой среде, экстраполируется для расчета приблизительного времени простоя в работающей системе. Именно в устаревшей системе будет выполняться миграция.

Во время этого тестирования все компоненты среды обычно отключаются и удаляются из сети для выполнения действий по миграции. 
Следовательно, необходимо отметить «Время простоя», необходимое для теста миграции. В идеале оно будет таким же, как и время миграции. Как правило, действия по миграции, определенные в документе «Руководство по миграции» (Migration Guide), включают:
- Фактическая миграция приложения;
- Брандмауэры, порты, хосты, аппаратные и программные конфигурации - все они изменяются в соответствии с новой системой, на которую переносится старая версия;
- Утечки данных, проверки безопасности;
- Проверяется связность между всеми компонентами приложения;

Тестировщикам рекомендуется проверить вышеизложенное в бэкенде системы или путем проведения тестирования белого ящика. 
После завершения миграции все серверы будут запущены, и будут выполнены базовые тесты, связанные с проверкой успешной миграции, что гарантирует, что все сквозные системы правильно подключены и все компоненты взаимодействуют друг с другом, БД запущен и работает, фронт успешно взаимодействует с бэком. Эти тесты должны быть идентифицированы заранее и записаны в документе «Спецификация тестов миграции» (Migration Test Specification document). Есть вероятность, что программное обеспечение поддерживает несколько разных платформ. В таком случае Миграцию необходимо проверять на каждой из этих платформ отдельно. Проверка сценариев миграции будет частью теста миграции.
Иногда отдельный сценарий миграции также проверяется с помощью «тестирования белого ящика» в автономной среде тестирования. 
Следовательно, миграционное тестирование будет представлять собой комбинацию тестирования белого и черного ящиков. После завершения этой проверки, связанной с миграцией, и прохождения соответствующих тестов команда может продолжить работу по тестированию после миграции.

Тестирование после миграции (Post-Migration testing)

После успешной миграции приложения вступает в действие тестирование после миграции. Здесь сквозное тестирование системы выполняется в тестовой среде. 
Тестировщики выполняют определенные тестовые наборы, тестовые сценарии, варианты использования с устаревшими данными, а также с новым набором данных. 
В дополнение к этому, есть определенные элементы, которые необходимо проверить в перенесенных средах:
- Все устаревшие данные перенесены в новое приложение в течение запланированного времени простоя. Чтобы убедиться в этом, сравните количество записей между устаревшим и новым приложением для каждой таблицы и представлений в базе данных;
- Все изменения схемы (поля и таблицы добавлены или удалены) в соответствии с новой системой обновлены;
- Данные, перенесенные из устаревшего приложения в новое, должны сохранять свое значение и формат, если только это не указано отдельно. Чтобы убедиться в этом, сравните значения данных между устаревшей и новой базами данных приложения;
- Перенесенные данные в новом приложении. Охватите здесь максимальное количество возможных причин. Для обеспечения 100% охвата проверки переноса данных используйте инструмент автоматизированного тестирования ;
- Безопасность базы данных;
- Целостность данных для всех возможных записей выборки;
- Ранее поддерживаемые функции в устаревшей системе работают должным образом в новой системе;
- Поток данных в приложении, который охватывает большинство компонентов;
- Интерфейс между компонентами должен быть тщательно протестирован, поскольку данные не должны изменяться, теряться и искажаться при прохождении через компоненты. Для проверки этого можно использовать интеграционные тестовые случаи;
- Избыточность устаревших данных. Никакие устаревшие данные не должны дублироваться во время миграции;
- Случаи несоответствия данных, такие как изменение типа данных, изменение формата хранения и т. д.;
- Все проверки на уровне поля в устаревшем приложении также должны выполняться в новом приложении;
- Любое добавление данных в новое приложение не должно отражаться на устаревшем;
- Обновление данных устаревшего приложения через новое приложение должно поддерживаться. После обновления в новом приложении оно не должно отражаться на устаревшем;
- Удаление данных устаревшего приложения в новом приложении должно поддерживаться. После удаления в новом приложении оно также не должно удалять данные в устаревшем;
- Убедитесь, что изменения, внесенные в устаревшую систему, поддерживают новые функции, предоставляемые как часть новой системы;
- Убедитесь, что пользователи устаревшей системы могут продолжать использовать как старые, так и новые функциональные возможности, особенно те, которые связаны с изменениями. Выполнение тестовых случаев и результатов тестирования, сохраненных во время тестирования перед миграцией;
- Создайте новых пользователей в системе и проведите тесты, чтобы убедиться, что функциональность как старого, так и нового приложения поддерживает вновь созданных пользователей и работает нормально;
- Проведите тесты функциональности на различных выборках данных (разные возрастные группы, пользователи из разных регионов и т.д.);
- Также необходимо проверить, включены ли «Флаги функций» для новых функций, а их включение/выключение позволяет включать и выключать функции;
- Тестирование производительности важно для того, чтобы убедиться, что переход на новые системы/программное обеспечение не ухудшил производительность системы;
- Также требуется проведение нагрузочных и стресс-тестов для обеспечения стабильности системы;
- Убедитесь, что обновление программного обеспечения не открыло никаких уязвимостей в системе безопасности, и, следовательно, проведите тестирование безопасности, особенно в той области, где в систему были внесены изменения во время миграции;
- Удобство использования - это еще один аспект, который необходимо проверить, в котором, если макет графического интерфейса пользователя / интерфейсная система изменились или изменилась какая-либо функциональность, какова простота использования, которую конечный пользователь чувствует по сравнению с устаревшей системой;

Поскольку скоуп тестирования после миграции становится очень большим, идеально разделить важные тесты, которые необходимо выполнить в первую очередь, чтобы удостовериться, что миграция прошла успешно, а затем выполнить оставшиеся позже.
Также рекомендуется автоматизировать сквозные функциональные тестовые случаи и другие возможные тестовые случаи, чтобы можно было сократить время тестирования и быстро получить результаты.
